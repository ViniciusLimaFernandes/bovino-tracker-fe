import {
  require_assert
} from "./chunk-PCPOGX7R.js";
import {
  NONCE_ACCOUNT_LENGTH,
  PublicKey,
  SYSVAR_RENT_PUBKEY,
  SendTransactionError,
  SystemProgram,
  Transaction,
  TransactionInstruction,
  index_browser_esm_exports,
  init_index_browser_esm,
  require_bn,
  require_bs58
} from "./chunk-XANKKFLI.js";
import {
  require_base64_js,
  require_buffer
} from "./chunk-YSWELEB7.js";
import {
  require_eventemitter3
} from "./chunk-HZZUBCGO.js";
import {
  __commonJS,
  __toCommonJS,
  __toESM
} from "./chunk-S5KM4IGW.js";

// node_modules/@project-serum/anchor/node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/@project-serum/anchor/node_modules/camelcase/index.js"(exports2, module2) {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x2) => options.pascalCase ? x2.charAt(0).toUpperCase() + x2.slice(1) : x2;
      if (Array.isArray(input)) {
        input = input.map((x2) => x2.trim()).filter((x2) => x2.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_2, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  }
});

// node_modules/js-sha256/src/sha256.js
var require_sha256 = __commonJS({
  "node_modules/js-sha256/src/sha256.js"(exports, module) {
    (function() {
      "use strict";
      var ERROR = "input is invalid type";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA256_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, is2242) {
        return function(message) {
          return new Sha256(is2242, true).update(message)[outputType]();
        };
      };
      var createMethod = function(is2242) {
        var method2 = createOutputMethod("hex", is2242);
        if (NODE_JS) {
          method2 = nodeWrap(method2, is2242);
        }
        method2.create = function() {
          return new Sha256(is2242);
        };
        method2.update = function(message) {
          return method2.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createOutputMethod(type, is2242);
        }
        return method2;
      };
      var nodeWrap = function(method, is224) {
        var crypto = eval("require('crypto')");
        var Buffer = eval("require('buffer').Buffer");
        var algorithm = is224 ? "sha224" : "sha256";
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash(algorithm).update(message, "utf8").digest("hex");
          } else {
            if (message === null || message === void 0) {
              throw new Error(ERROR);
            } else if (message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            }
          }
          if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
            return crypto.createHash(algorithm).update(new Buffer(message)).digest("hex");
          } else {
            return method(message);
          }
        };
        return nodeMethod;
      };
      var createHmacOutputMethod = function(outputType, is2242) {
        return function(key, message) {
          return new HmacSha256(key, is2242, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(is2242) {
        var method2 = createHmacOutputMethod("hex", is2242);
        method2.create = function(key) {
          return new HmacSha256(key, is2242);
        };
        method2.update = function(key, message) {
          return method2.create(key).update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method2[type] = createHmacOutputMethod(type, is2242);
        }
        return method2;
      };
      function Sha256(is2242, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (is2242) {
          this.h0 = 3238371032;
          this.h1 = 914150663;
          this.h2 = 812702999;
          this.h3 = 4144912697;
          this.h4 = 4290775857;
          this.h5 = 1750603025;
          this.h6 = 1694076839;
          this.h7 = 3204075428;
        } else {
          this.h0 = 1779033703;
          this.h1 = 3144134277;
          this.h2 = 1013904242;
          this.h3 = 2773480762;
          this.h4 = 1359893119;
          this.h5 = 2600822924;
          this.h6 = 528734635;
          this.h7 = 1541459225;
        }
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
        this.is224 = is2242;
      }
      Sha256.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
          notString = true;
        }
        var code, index = 0, i, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            for (i = this.start; index < length && i < 64; ++index) {
              blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
            }
          } else {
            for (i = this.start; index < length && i < 64; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i >> 2] |= code << SHIFT[i++ & 3];
              } else if (code < 2048) {
                blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.block = blocks2[16];
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha256.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[16] = this.block;
        blocks2[i >> 2] |= EXTRA[i & 3];
        this.block = blocks2[16];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[15] = this.bytes << 3;
        this.hash();
      };
      Sha256.prototype.hash = function() {
        var a = this.h0, b2 = this.h1, c = this.h2, d2 = this.h3, e = this.h4, f2 = this.h5, g2 = this.h6, h2 = this.h7, blocks2 = this.blocks, j2, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;
        for (j2 = 16; j2 < 64; ++j2) {
          t1 = blocks2[j2 - 15];
          s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;
          t1 = blocks2[j2 - 2];
          s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          blocks2[j2] = blocks2[j2 - 16] + s0 + blocks2[j2 - 7] + s1 << 0;
        }
        bc = b2 & c;
        for (j2 = 0; j2 < 64; j2 += 4) {
          if (this.first) {
            if (this.is224) {
              ab = 300032;
              t1 = blocks2[0] - 1413257819;
              h2 = t1 - 150054599 << 0;
              d2 = t1 + 24177077 << 0;
            } else {
              ab = 704751109;
              t1 = blocks2[0] - 210244248;
              h2 = t1 - 1521486534 << 0;
              d2 = t1 + 143694565 << 0;
            }
            this.first = false;
          } else {
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ab = a & b2;
            maj = ab ^ a & c ^ bc;
            ch = e & f2 ^ ~e & g2;
            t1 = h2 + s1 + ch + K[j2] + blocks2[j2];
            t2 = s0 + maj;
            h2 = d2 + t1 << 0;
            d2 = t1 + t2 << 0;
          }
          s0 = (d2 >>> 2 | d2 << 30) ^ (d2 >>> 13 | d2 << 19) ^ (d2 >>> 22 | d2 << 10);
          s1 = (h2 >>> 6 | h2 << 26) ^ (h2 >>> 11 | h2 << 21) ^ (h2 >>> 25 | h2 << 7);
          da = d2 & a;
          maj = da ^ d2 & b2 ^ ab;
          ch = h2 & e ^ ~h2 & f2;
          t1 = g2 + s1 + ch + K[j2 + 1] + blocks2[j2 + 1];
          t2 = s0 + maj;
          g2 = c + t1 << 0;
          c = t1 + t2 << 0;
          s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);
          s1 = (g2 >>> 6 | g2 << 26) ^ (g2 >>> 11 | g2 << 21) ^ (g2 >>> 25 | g2 << 7);
          cd = c & d2;
          maj = cd ^ c & a ^ da;
          ch = g2 & h2 ^ ~g2 & e;
          t1 = f2 + s1 + ch + K[j2 + 2] + blocks2[j2 + 2];
          t2 = s0 + maj;
          f2 = b2 + t1 << 0;
          b2 = t1 + t2 << 0;
          s0 = (b2 >>> 2 | b2 << 30) ^ (b2 >>> 13 | b2 << 19) ^ (b2 >>> 22 | b2 << 10);
          s1 = (f2 >>> 6 | f2 << 26) ^ (f2 >>> 11 | f2 << 21) ^ (f2 >>> 25 | f2 << 7);
          bc = b2 & c;
          maj = bc ^ b2 & d2 ^ cd;
          ch = f2 & g2 ^ ~f2 & h2;
          t1 = e + s1 + ch + K[j2 + 3] + blocks2[j2 + 3];
          t2 = s0 + maj;
          e = a + t1 << 0;
          a = t1 + t2 << 0;
        }
        this.h0 = this.h0 + a << 0;
        this.h1 = this.h1 + b2 << 0;
        this.h2 = this.h2 + c << 0;
        this.h3 = this.h3 + d2 << 0;
        this.h4 = this.h4 + e << 0;
        this.h5 = this.h5 + f2 << 0;
        this.h6 = this.h6 + g2 << 0;
        this.h7 = this.h7 + h2 << 0;
      };
      Sha256.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var hex = HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[h4 & 15] + HEX_CHARS[h5 >> 28 & 15] + HEX_CHARS[h5 >> 24 & 15] + HEX_CHARS[h5 >> 20 & 15] + HEX_CHARS[h5 >> 16 & 15] + HEX_CHARS[h5 >> 12 & 15] + HEX_CHARS[h5 >> 8 & 15] + HEX_CHARS[h5 >> 4 & 15] + HEX_CHARS[h5 & 15] + HEX_CHARS[h6 >> 28 & 15] + HEX_CHARS[h6 >> 24 & 15] + HEX_CHARS[h6 >> 20 & 15] + HEX_CHARS[h6 >> 16 & 15] + HEX_CHARS[h6 >> 12 & 15] + HEX_CHARS[h6 >> 8 & 15] + HEX_CHARS[h6 >> 4 & 15] + HEX_CHARS[h6 & 15];
        if (!this.is224) {
          hex += HEX_CHARS[h7 >> 28 & 15] + HEX_CHARS[h7 >> 24 & 15] + HEX_CHARS[h7 >> 20 & 15] + HEX_CHARS[h7 >> 16 & 15] + HEX_CHARS[h7 >> 12 & 15] + HEX_CHARS[h7 >> 8 & 15] + HEX_CHARS[h7 >> 4 & 15] + HEX_CHARS[h7 & 15];
        }
        return hex;
      };
      Sha256.prototype.toString = Sha256.prototype.hex;
      Sha256.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7;
        var arr = [
          h0 >> 24 & 255,
          h0 >> 16 & 255,
          h0 >> 8 & 255,
          h0 & 255,
          h1 >> 24 & 255,
          h1 >> 16 & 255,
          h1 >> 8 & 255,
          h1 & 255,
          h2 >> 24 & 255,
          h2 >> 16 & 255,
          h2 >> 8 & 255,
          h2 & 255,
          h3 >> 24 & 255,
          h3 >> 16 & 255,
          h3 >> 8 & 255,
          h3 & 255,
          h4 >> 24 & 255,
          h4 >> 16 & 255,
          h4 >> 8 & 255,
          h4 & 255,
          h5 >> 24 & 255,
          h5 >> 16 & 255,
          h5 >> 8 & 255,
          h5 & 255,
          h6 >> 24 & 255,
          h6 >> 16 & 255,
          h6 >> 8 & 255,
          h6 & 255
        ];
        if (!this.is224) {
          arr.push(h7 >> 24 & 255, h7 >> 16 & 255, h7 >> 8 & 255, h7 & 255);
        }
        return arr;
      };
      Sha256.prototype.array = Sha256.prototype.digest;
      Sha256.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer = new ArrayBuffer(this.is224 ? 28 : 32);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0);
        dataView.setUint32(4, this.h1);
        dataView.setUint32(8, this.h2);
        dataView.setUint32(12, this.h3);
        dataView.setUint32(16, this.h4);
        dataView.setUint32(20, this.h5);
        dataView.setUint32(24, this.h6);
        if (!this.is224) {
          dataView.setUint32(28, this.h7);
        }
        return buffer;
      };
      function HmacSha256(key, is2242, sharedMemory) {
        var i, type = typeof key;
        if (type === "string") {
          var bytes = [], length = key.length, index = 0, code;
          for (i = 0; i < length; ++i) {
            code = key.charCodeAt(i);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        } else {
          if (type === "object") {
            if (key === null) {
              throw new Error(ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(ERROR);
              }
            }
          } else {
            throw new Error(ERROR);
          }
        }
        if (key.length > 64) {
          key = new Sha256(is2242, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (i = 0; i < 64; ++i) {
          var b2 = key[i] || 0;
          oKeyPad[i] = 92 ^ b2;
          iKeyPad[i] = 54 ^ b2;
        }
        Sha256.call(this, is2242, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha256.prototype = new Sha256();
      HmacSha256.prototype.finalize = function() {
        Sha256.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha256.call(this, this.is224, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha256.prototype.finalize.call(this);
        }
      };
      var exports = createMethod();
      exports.sha256 = exports;
      exports.sha224 = createMethod(true);
      exports.sha256.hmac = createHmacMethod();
      exports.sha224.hmac = createHmacMethod(true);
      if (COMMON_JS) {
        module.exports = exports;
      } else {
        root.sha256 = exports.sha256;
        root.sha224 = exports.sha224;
        if (AMD) {
          define(function() {
            return exports;
          });
        }
      }
    })();
  }
});

// node_modules/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "node_modules/buffer-layout/lib/Layout.js"(exports2) {
    "use strict";
    var Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      makeDestinationObject() {
        return {};
      }
      decode(b2, offset) {
        throw new Error("Layout is abstract");
      }
      encode(src, b2, offset) {
        throw new Error("Layout is abstract");
      }
      getSpan(b2, offset) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      fromArray(values) {
        return void 0;
      }
    };
    exports2.Layout = Layout;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports2.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Class.hasOwnProperty("layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (layout.hasOwnProperty("boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value: function(b2, offset) {
          return layout.encode(this, b2, offset);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value: function(b2, offset) {
          return layout.decode(b2, offset);
        },
        writable: true
      });
    }
    exports2.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout {
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan, property) {
        if (void 0 === elementSpan) {
          elementSpan = 1;
        }
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      isCount() {
        return true;
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rem = b2.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      encode(src, b2, offset) {
        return 0;
      }
    };
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (void 0 === offset) {
          offset = 0;
        } else if (!Number.isInteger(offset)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset;
      }
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.decode(b2, offset + this.offset);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return this.layout.encode(src, b2, offset + this.offset);
      }
    };
    var UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readUIntLE(offset, this.span);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeUIntLE(src, offset, this.span);
        return this.span;
      }
    };
    var UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readUIntBE(offset, this.span);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeUIntBE(src, offset, this.span);
        return this.span;
      }
    };
    var Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readIntLE(offset, this.span);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeIntLE(src, offset, this.span);
        return this.span;
      }
    };
    var IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readIntBE(offset, this.span);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeIntBE(src, offset, this.span);
        return this.span;
      }
    };
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src) {
      const hi32 = Math.floor(src / V2E32);
      const lo32 = src - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b2.readUInt32LE(offset);
        const hi32 = b2.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b2.writeUInt32LE(split.lo32, offset);
        b2.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    var NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b2.readUInt32BE(offset);
        const lo32 = b2.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b2.writeUInt32BE(split.hi32, offset);
        b2.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    var NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const lo32 = b2.readUInt32LE(offset);
        const hi32 = b2.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b2.writeUInt32LE(split.lo32, offset);
        b2.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    };
    var NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const hi32 = b2.readInt32BE(offset);
        const lo32 = b2.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const split = divmodInt64(src);
        b2.writeInt32BE(split.hi32, offset);
        b2.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    };
    var Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readFloatLE(offset);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeFloatLE(src, offset);
        return 4;
      }
    };
    var FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readFloatBE(offset);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeFloatBE(src, offset);
        return 4;
      }
    };
    var Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readDoubleLE(offset);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeDoubleLE(src, offset);
        return 8;
      }
    };
    var DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.readDoubleBE(offset);
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        b2.writeDoubleBE(src, offset);
        return 8;
      }
    };
    var Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      getSpan(b2, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b2, offset);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b2, offset + span);
            ++idx;
          }
        }
        return span;
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b2, offset);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b2, offset));
          offset += this.elementLayout.getSpan(b2, offset);
          i += 1;
        }
        return rv;
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const elo = this.elementLayout;
        const span = src.reduce((span2, v2) => {
          return span2 + elo.encode(v2, b2, offset + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b2, offset);
        }
        return span;
      }
    };
    var Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v2) => acc && v2 instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      getSpan(b2, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b2, offset);
            offset += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b2, offset);
          }
          offset += fd.getSpan(b2, offset);
          if (this.decodePrefixes && b2.length === offset) {
            break;
          }
        }
        return dest;
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const firstOffset = offset;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b2, offset);
              if (0 > span) {
                span = fd.getSpan(b2, offset);
              }
            }
          }
          lastOffset = offset;
          offset += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset;
          }
          if (0 > fd.span) {
            offset = -1;
          } else if (0 <= offset) {
            offset += fd.span;
          }
        }
      }
    };
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      decode() {
        throw new Error("UnionDiscriminator is abstract");
      }
      encode() {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      decode(b2, offset) {
        return this.layout.decode(b2, offset);
      }
      encode(src, b2, offset) {
        return this.layout.encode(src, b2, offset);
      }
    };
    var Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        const upv = discr instanceof UInt || discr instanceof UIntBE;
        if (upv) {
          discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discr = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && upv) {
            span += discr.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discr;
        this.usesPrefixDiscriminator = upv;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src) {
          return boundGetSourceVariant(src);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      getSpan(b2, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getVariant(b2, offset);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b2, offset);
      }
      defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src[this.discriminator.property]];
          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (src.hasOwnProperty(vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b2, offset);
        let clo = this.registry[discr];
        if (void 0 === clo) {
          let contentOffset = 0;
          clo = this.defaultLayout;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b2, offset + contentOffset);
        } else {
          dest = clo.decode(b2, offset);
        }
        return dest;
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const vlo = this.getSourceVariant(src);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src[dlo.property], b2, offset);
          return contentOffset + clo.encode(
            src[clo.property],
            b2,
            offset + contentOffset
          );
        }
        return vlo.encode(src, b2, offset);
      }
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      getVariant(vb, offset) {
        let variant = vb;
        if (Buffer.isBuffer(vb)) {
          if (void 0 === offset) {
            offset = 0;
          }
          variant = this.discriminator.decode(vb, offset);
        }
        return this.registry[variant];
      }
    };
    var VariantLayout = class extends Layout {
      constructor(union, variant, layout, property) {
        if (!(union instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union.span;
        if (0 > union.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union.usesPrefixDiscriminator) {
            span += union.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union;
        this.variant = variant;
        this.layout = layout || null;
      }
      getSpan(b2, offset) {
        if (0 <= this.span) {
          return this.span;
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        return contentOffset + this.layout.getSpan(b2, offset + contentOffset);
      }
      decode(b2, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        if (this !== this.union.getVariant(b2, offset)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b2, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b2, offset);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src[this.property], b2, offset + contentOffset);
          span += this.layout.getSpan(b2, offset + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    };
    function fixBitwiseResult(v2) {
      if (0 > v2) {
        v2 += 4294967296;
      }
      return v2;
    }
    var BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = void 0;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v2) {
          value = fixBitwiseResult(v2);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      decode(b2, offset) {
        const dest = this.makeDestinationObject();
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b2, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(value);
          }
        }
        return dest;
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        const value = this.word.decode(b2, offset);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b2, offset);
      }
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      addBoolean(property) {
        const bf = new Boolean(this, property);
        this.fields.push(bf);
        return bf;
      }
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
      }
    };
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      decode() {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    var Boolean = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      decode(b2, offset) {
        return !!BitField.prototype.decode.call(this, b2, offset);
      }
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        return BitField.prototype.encode.call(this, value);
      }
    };
    var Blob2 = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      getSpan(b2, offset) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b2, offset);
        }
        return span;
      }
      decode(b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b2, offset);
        }
        return b2.slice(offset, offset + span);
      }
      encode(src, b2, offset) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }
        if (!(Buffer.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Buffer as src");
        }
        if (offset + span > b2.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        b2.write(src.toString("hex"), offset, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b2, offset);
        }
        return span;
      }
    };
    var CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      getSpan(b2, offset) {
        if (!Buffer.isBuffer(b2)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        let idx = offset;
        while (idx < b2.length && 0 !== b2[idx]) {
          idx += 1;
        }
        return 1 + idx - offset;
      }
      decode(b2, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b2, offset);
        return b2.slice(offset, offset + span - 1).toString("utf-8");
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (offset + span > b2.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b2, offset);
        b2[offset + span] = 0;
        return span + 1;
      }
    };
    var UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      getSpan(b2, offset) {
        if (!Buffer.isBuffer(b2)) {
          throw new TypeError("b must be a Buffer");
        }
        if (void 0 === offset) {
          offset = 0;
        }
        return b2.length - offset;
      }
      decode(b2, offset, dest) {
        if (void 0 === offset) {
          offset = 0;
        }
        let span = this.getSpan(b2, offset);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return b2.slice(offset, offset + span).toString("utf-8");
      }
      encode(src, b2, offset) {
        if (void 0 === offset) {
          offset = 0;
        }
        if ("string" !== typeof src) {
          src = src.toString();
        }
        const srcb = new Buffer(src, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset + span > b2.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(b2, offset);
        return span;
      }
    };
    var Constant = class extends Layout {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      decode(b2, offset, dest) {
        return this.value;
      }
      encode(src, b2, offset) {
        return 0;
      }
    };
    exports2.ExternalLayout = ExternalLayout;
    exports2.GreedyCount = GreedyCount;
    exports2.OffsetLayout = OffsetLayout;
    exports2.UInt = UInt;
    exports2.UIntBE = UIntBE;
    exports2.Int = Int;
    exports2.IntBE = IntBE;
    exports2.Float = Float;
    exports2.FloatBE = FloatBE;
    exports2.Double = Double;
    exports2.DoubleBE = DoubleBE;
    exports2.Sequence = Sequence;
    exports2.Structure = Structure;
    exports2.UnionDiscriminator = UnionDiscriminator;
    exports2.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    exports2.Union = Union;
    exports2.VariantLayout = VariantLayout;
    exports2.BitStructure = BitStructure;
    exports2.BitField = BitField;
    exports2.Boolean = Boolean;
    exports2.Blob = Blob2;
    exports2.CString = CString;
    exports2.UTF8 = UTF8;
    exports2.Constant = Constant;
    exports2.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports2.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);
    exports2.u8 = (property) => new UInt(1, property);
    exports2.u16 = (property) => new UInt(2, property);
    exports2.u24 = (property) => new UInt(3, property);
    exports2.u32 = (property) => new UInt(4, property);
    exports2.u40 = (property) => new UInt(5, property);
    exports2.u48 = (property) => new UInt(6, property);
    exports2.nu64 = (property) => new NearUInt64(property);
    exports2.u16be = (property) => new UIntBE(2, property);
    exports2.u24be = (property) => new UIntBE(3, property);
    exports2.u32be = (property) => new UIntBE(4, property);
    exports2.u40be = (property) => new UIntBE(5, property);
    exports2.u48be = (property) => new UIntBE(6, property);
    exports2.nu64be = (property) => new NearUInt64BE(property);
    exports2.s8 = (property) => new Int(1, property);
    exports2.s16 = (property) => new Int(2, property);
    exports2.s24 = (property) => new Int(3, property);
    exports2.s32 = (property) => new Int(4, property);
    exports2.s40 = (property) => new Int(5, property);
    exports2.s48 = (property) => new Int(6, property);
    exports2.ns64 = (property) => new NearInt64(property);
    exports2.s16be = (property) => new IntBE(2, property);
    exports2.s24be = (property) => new IntBE(3, property);
    exports2.s32be = (property) => new IntBE(4, property);
    exports2.s40be = (property) => new IntBE(5, property);
    exports2.s48be = (property) => new IntBE(6, property);
    exports2.ns64be = (property) => new NearInt64BE(property);
    exports2.f32 = (property) => new Float(property);
    exports2.f32be = (property) => new FloatBE(property);
    exports2.f64 = (property) => new Double(property);
    exports2.f64be = (property) => new DoubleBE(property);
    exports2.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports2.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports2.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports2.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports2.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports2.blob = (length, property) => new Blob2(length, property);
    exports2.cstr = (property) => new CString(property);
    exports2.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports2.const = (value, property) => new Constant(value, property);
  }
});

// node_modules/@project-serum/borsh/dist/lib/index.js
var require_lib = __commonJS({
  "node_modules/@project-serum/borsh/dist/lib/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.map = exports2.array = exports2.rustEnum = exports2.str = exports2.vecU8 = exports2.tagged = exports2.vec = exports2.bool = exports2.option = exports2.publicKey = exports2.i128 = exports2.u128 = exports2.i64 = exports2.u64 = exports2.struct = exports2.f64 = exports2.f32 = exports2.i32 = exports2.u32 = exports2.i16 = exports2.u16 = exports2.i8 = exports2.u8 = void 0;
    var buffer_layout_1 = require_Layout();
    var web3_js_1 = (init_index_browser_esm(), __toCommonJS(index_browser_esm_exports));
    var bn_js_1 = __importDefault(require_bn());
    var buffer_layout_2 = require_Layout();
    Object.defineProperty(exports2, "u8", { enumerable: true, get: function() {
      return buffer_layout_2.u8;
    } });
    Object.defineProperty(exports2, "i8", { enumerable: true, get: function() {
      return buffer_layout_2.s8;
    } });
    Object.defineProperty(exports2, "u16", { enumerable: true, get: function() {
      return buffer_layout_2.u16;
    } });
    Object.defineProperty(exports2, "i16", { enumerable: true, get: function() {
      return buffer_layout_2.s16;
    } });
    Object.defineProperty(exports2, "u32", { enumerable: true, get: function() {
      return buffer_layout_2.u32;
    } });
    Object.defineProperty(exports2, "i32", { enumerable: true, get: function() {
      return buffer_layout_2.s32;
    } });
    Object.defineProperty(exports2, "f32", { enumerable: true, get: function() {
      return buffer_layout_2.f32;
    } });
    Object.defineProperty(exports2, "f64", { enumerable: true, get: function() {
      return buffer_layout_2.f64;
    } });
    Object.defineProperty(exports2, "struct", { enumerable: true, get: function() {
      return buffer_layout_2.struct;
    } });
    var BNLayout = class extends buffer_layout_1.Layout {
      constructor(span, signed, property) {
        super(span, property);
        this.blob = buffer_layout_1.blob(span);
        this.signed = signed;
      }
      decode(b2, offset = 0) {
        const num = new bn_js_1.default(this.blob.decode(b2, offset), 10, "le");
        if (this.signed) {
          return num.fromTwos(this.span * 8).clone();
        }
        return num;
      }
      encode(src, b2, offset = 0) {
        if (this.signed) {
          src = src.toTwos(this.span * 8);
        }
        return this.blob.encode(src.toArrayLike(Buffer, "le", this.span), b2, offset);
      }
    };
    function u642(property) {
      return new BNLayout(8, false, property);
    }
    exports2.u64 = u642;
    function i642(property) {
      return new BNLayout(8, true, property);
    }
    exports2.i64 = i642;
    function u1282(property) {
      return new BNLayout(16, false, property);
    }
    exports2.u128 = u1282;
    function i1282(property) {
      return new BNLayout(16, true, property);
    }
    exports2.i128 = i1282;
    var WrappedLayout = class extends buffer_layout_1.Layout {
      constructor(layout, decoder, encoder, property) {
        super(layout.span, property);
        this.layout = layout;
        this.decoder = decoder;
        this.encoder = encoder;
      }
      decode(b2, offset) {
        return this.decoder(this.layout.decode(b2, offset));
      }
      encode(src, b2, offset) {
        return this.layout.encode(this.encoder(src), b2, offset);
      }
      getSpan(b2, offset) {
        return this.layout.getSpan(b2, offset);
      }
    };
    function publicKey2(property) {
      return new WrappedLayout(buffer_layout_1.blob(32), (b2) => new web3_js_1.PublicKey(b2), (key) => key.toBuffer(), property);
    }
    exports2.publicKey = publicKey2;
    var OptionLayout = class extends buffer_layout_1.Layout {
      constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = buffer_layout_1.u8();
      }
      encode(src, b2, offset = 0) {
        if (src === null || src === void 0) {
          return this.discriminator.encode(0, b2, offset);
        }
        this.discriminator.encode(1, b2, offset);
        return this.layout.encode(src, b2, offset + 1) + 1;
      }
      decode(b2, offset = 0) {
        const discriminator = this.discriminator.decode(b2, offset);
        if (discriminator === 0) {
          return null;
        } else if (discriminator === 1) {
          return this.layout.decode(b2, offset + 1);
        }
        throw new Error("Invalid option " + this.property);
      }
      getSpan(b2, offset = 0) {
        const discriminator = this.discriminator.decode(b2, offset);
        if (discriminator === 0) {
          return 1;
        } else if (discriminator === 1) {
          return this.layout.getSpan(b2, offset + 1) + 1;
        }
        throw new Error("Invalid option " + this.property);
      }
    };
    function option2(layout, property) {
      return new OptionLayout(layout, property);
    }
    exports2.option = option2;
    function bool2(property) {
      return new WrappedLayout(buffer_layout_1.u8(), decodeBool, encodeBool, property);
    }
    exports2.bool = bool2;
    function decodeBool(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }
      throw new Error("Invalid bool: " + value);
    }
    function encodeBool(value) {
      return value ? 1 : 0;
    }
    function vec2(elementLayout, property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.seq(elementLayout, buffer_layout_1.offset(length, -length.span), "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.vec = vec2;
    function tagged(tag, layout, property) {
      const wrappedLayout = buffer_layout_1.struct([
        u642("tag"),
        layout.replicate("data")
      ]);
      function decodeTag({ tag: receivedTag, data }) {
        if (!receivedTag.eq(tag)) {
          throw new Error("Invalid tag, expected: " + tag.toString("hex") + ", got: " + receivedTag.toString("hex"));
        }
        return data;
      }
      return new WrappedLayout(wrappedLayout, decodeTag, (data) => ({ tag, data }), property);
    }
    exports2.tagged = tagged;
    function vecU82(property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.blob(buffer_layout_1.offset(length, -length.span), "data")
      ]);
      return new WrappedLayout(layout, ({ data }) => data, (data) => ({ data }), property);
    }
    exports2.vecU8 = vecU82;
    function str2(property) {
      return new WrappedLayout(vecU82(), (data) => data.toString("utf-8"), (s) => Buffer.from(s, "utf-8"), property);
    }
    exports2.str = str2;
    function rustEnum2(variants, property, discriminant) {
      const unionLayout = buffer_layout_1.union(discriminant !== null && discriminant !== void 0 ? discriminant : buffer_layout_1.u8(), property);
      variants.forEach((variant, index) => unionLayout.addVariant(index, variant, variant.property));
      return unionLayout;
    }
    exports2.rustEnum = rustEnum2;
    function array2(elementLayout, length, property) {
      const layout = buffer_layout_1.struct([
        buffer_layout_1.seq(elementLayout, length, "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => values, (values) => ({ values }), property);
    }
    exports2.array = array2;
    var MapEntryLayout = class extends buffer_layout_1.Layout {
      constructor(keyLayout, valueLayout, property) {
        super(keyLayout.span + valueLayout.span, property);
        this.keyLayout = keyLayout;
        this.valueLayout = valueLayout;
      }
      decode(b2, offset) {
        offset = offset || 0;
        const key = this.keyLayout.decode(b2, offset);
        const value = this.valueLayout.decode(b2, offset + this.keyLayout.getSpan(b2, offset));
        return [key, value];
      }
      encode(src, b2, offset) {
        offset = offset || 0;
        const keyBytes = this.keyLayout.encode(src[0], b2, offset);
        const valueBytes = this.valueLayout.encode(src[1], b2, offset + keyBytes);
        return keyBytes + valueBytes;
      }
      getSpan(b2, offset) {
        return this.keyLayout.getSpan(b2, offset) + this.valueLayout.getSpan(b2, offset);
      }
    };
    function map(keyLayout, valueLayout, property) {
      const length = buffer_layout_1.u32("length");
      const layout = buffer_layout_1.struct([
        length,
        buffer_layout_1.seq(new MapEntryLayout(keyLayout, valueLayout), buffer_layout_1.offset(length, -length.span), "values")
      ]);
      return new WrappedLayout(layout, ({ values }) => new Map(values), (values) => ({ values: Array.from(values.entries()) }), property);
    }
    exports2.map = map;
  }
});

// node_modules/@project-serum/anchor/dist/browser/index.js
var import_buffer = __toESM(require_buffer());
init_index_browser_esm();
init_index_browser_esm();
var import_bn = __toESM(require_bn());
var import_bn2 = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());
var l = __toESM(require_base64_js());
var import_camelcase = __toESM(require_camelcase());
var import_js_sha256 = __toESM(require_sha256());
var f = __toESM(require_lib());

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w2) => {
  s.pending_buf[s.pending++] = w2 & 255;
  s.pending_buf[s.pending++] = w2 >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h2;
  let n, m;
  let bits;
  let xbits;
  let f2;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h2 = s.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
    n = s.heap[h2];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f2 = tree[n * 2];
    s.opt_len += f2 * (bits + xbits);
    if (has_stree) {
      s.static_len += f2 * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h2];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    let len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var copy_block = (s, buf, len, header) => {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);
  s.pending += len;
};
var smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
var pqdownheap = (s, tree, k2) => {
  const v2 = s.heap[k2];
  let j2 = k2 << 1;
  while (j2 <= s.heap_len) {
    if (j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)) {
      j2++;
    }
    if (smaller(tree, v2, s.heap[j2], s.depth)) {
      break;
    }
    s.heap[k2] = s.heap[j2];
    k2 = j2;
    j2 <<= 1;
  }
  s.heap[k2] = v2;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let lx = 0;
  let code;
  let extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let black_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k2 = 0; k2 < 8; k2++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t2 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f2) => {
  return (f2 << 1) - (f2 > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b2) => {
  s.pending_buf[s.pending++] = b2;
};
var putShortMSB = (s, b2) => {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let p2, n, m, more, str2;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p2 = n;
      do {
        m = s.head[--p2];
        s.head[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p2 = n;
      do {
        m = s.prev[--p2];
        s.prev[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str2 = s.strstart - s.insert;
      s.ins_h = s.window[str2];
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
        s.prev[str2 & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str2;
        str2++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    const max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH$2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method2, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method2;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  let beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  s.strm = strm;
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str2 = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str2 + MIN_MATCH - 1]);
      s.prev[str2 & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str2;
      str2++;
    } while (--n);
    s.strstart = str2;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l2 = chunks.length; i < l2; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l2 = chunks.length; i < l2; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q2 = 0; q2 < 256; q2++) {
  _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str2) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str2);
  }
  let buf, c, c2, m_pos, i, str_len = str2.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str2.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str2.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate$1(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return deflate$1(input, options);
}
function gzip$1(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate$1(input, options);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root2 = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root2 = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root2 > max) {
    root2 = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root2 < min) {
    root2 = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root2;
  drop = 0;
  low = -1;
  used = 1 << root2;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root2 && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root2;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root2;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA2 = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q2) => {
  return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA2;
        case EXTRA2:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    next + copy
                  ),
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate$1(options);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options) {
  options = options || {};
  options.raw = true;
  return inflate$1(input, options);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/@project-serum/anchor/dist/browser/index.js
var import_eventemitter3 = __toESM(require_eventemitter3());
var g = __toESM(require_assert());
var w = Object.freeze({ __proto__: null, encode: function(t2) {
  return t2.reduce((t3, e) => t3 + e.toString(16).padStart(2, "0"), "0x");
}, decode: function(e) {
  0 === e.indexOf("0x") && (e = e.substr(2)), e.length % 2 == 1 && (e = "0" + e);
  let n = e.match(/.{2}/g);
  return null === n ? import_buffer.Buffer.from([]) : import_buffer.Buffer.from(n.map((t2) => parseInt(t2, 16)));
} });
function v(t2) {
  return new TextDecoder("utf-8").decode(t2);
}
function b(t2) {
  return new TextEncoder().encode(t2);
}
var A = Object.freeze({ __proto__: null, decode: v, encode: b });
function _(t2) {
  return import_bs58.default.encode(t2);
}
var S = Object.freeze({ __proto__: null, encode: _, decode: function(t2) {
  return import_bs58.default.decode(t2);
} });
function E(e) {
  return import_buffer.Buffer.from(l.toByteArray(e));
}
var I = Object.freeze({ __proto__: null, encode: function(t2) {
  return l.fromByteArray(t2);
}, decode: E });
var k = Object.freeze({ __proto__: null, hex: w, utf8: A, bs58: S, base64: I });
function M(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.errors && t2.errors.forEach((t3) => {
    var n;
    let r = null !== (n = t3.msg) && void 0 !== n ? n : t3.name;
    e.set(t3.code, r);
  }), e;
}
function x(t2, ...e) {
  if (t2.args.length != e.length)
    throw new Error("Invalid argument length");
  const n = {};
  let r = 0;
  return t2.args.forEach((t3) => {
    n[t3.name] = e[r], r += 1;
  }), n;
}
function P(t2, e = {}) {
  t2.forEach((t3) => {
    if ("accounts" in t3)
      P(t3.accounts, e[t3.name]);
    else if (void 0 === e[t3.name])
      throw new Error(`Invalid arguments: ${t3.name} not provided.`);
  });
}
function L(t2) {
  return t2 instanceof PublicKey ? t2 : new PublicKey(t2);
}
var T = class extends TypeError {
  constructor(t2, e) {
    let n;
    const { message: r, ...o } = t2, { path: i } = t2;
    super(0 === i.length ? r : "At path: " + i.join(".") + " -- " + r), this.value = void 0, this.key = void 0, this.type = void 0, this.refinement = void 0, this.path = void 0, this.branch = void 0, this.failures = void 0, Object.assign(this, o), this.name = this.constructor.name, this.failures = () => {
      var r2;
      return null != (r2 = n) ? r2 : n = [t2, ...e()];
    };
  }
};
function C(t2) {
  return "object" == typeof t2 && null != t2;
}
function z(t2) {
  return "string" == typeof t2 ? JSON.stringify(t2) : "" + t2;
}
function B(t2, e, n, r) {
  if (true === t2)
    return;
  false === t2 ? t2 = {} : "string" == typeof t2 && (t2 = { message: t2 });
  const { path: o, branch: i } = e, { type: s } = n, { refinement: a, message: c = "Expected a value of type `" + s + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + z(r) + "`" } = t2;
  return { value: r, type: s, refinement: a, key: o[o.length - 1], path: o, branch: i, ...t2, message: c };
}
function* O(t2, e, n, r) {
  var o;
  C(o = t2) && "function" == typeof o[Symbol.iterator] || (t2 = [t2]);
  for (const o2 of t2) {
    const t3 = B(o2, e, n, r);
    t3 && (yield t3);
  }
}
function* D(t2, e, n) {
  void 0 === n && (n = {});
  const { path: r = [], branch: o = [t2], coerce: i = false, mask: s = false } = n, a = { path: r, branch: o };
  if (i && (t2 = e.coercer(t2, a), s && "type" !== e.type && C(e.schema) && C(t2) && !Array.isArray(t2)))
    for (const n2 in t2)
      void 0 === e.schema[n2] && delete t2[n2];
  let c = true;
  for (const n2 of e.validator(t2, a))
    c = false, yield [n2, void 0];
  for (let [n2, u2, d2] of e.entries(t2, a)) {
    const e2 = D(u2, d2, { path: void 0 === n2 ? r : [...r, n2], branch: void 0 === n2 ? o : [...o, u2], coerce: i, mask: s });
    for (const r2 of e2)
      r2[0] ? (c = false, yield [r2[0], void 0]) : i && (u2 = r2[1], void 0 === n2 ? t2 = u2 : t2 instanceof Map ? t2.set(n2, u2) : t2 instanceof Set ? t2.add(u2) : C(t2) && (t2[n2] = u2));
  }
  if (c)
    for (const n2 of e.refiner(t2, a))
      c = false, yield [n2, void 0];
  c && (yield [void 0, t2]);
}
var N = class {
  constructor(t2) {
    this.TYPE = void 0, this.type = void 0, this.schema = void 0, this.coercer = void 0, this.validator = void 0, this.refiner = void 0, this.entries = void 0;
    const { type: e, schema: n, validator: r, refiner: o, coercer: i = (t3) => t3, entries: s = function* () {
    } } = t2;
    this.type = e, this.schema = n, this.entries = s, this.coercer = i, this.validator = r ? (t3, e2) => O(r(t3, e2), e2, this, t3) : () => [], this.refiner = o ? (t3, e2) => O(o(t3, e2), e2, this, t3) : () => [];
  }
  assert(t2) {
    return function(t3, e) {
      const n = U(t3, e);
      if (n[0])
        throw n[0];
    }(t2, this);
  }
  create(t2) {
    return R(t2, this);
  }
  is(t2) {
    return V(t2, this);
  }
  mask(t2) {
    return function(t3, e) {
      const n = U(t3, e, { coerce: true, mask: true });
      if (n[0])
        throw n[0];
      return n[1];
    }(t2, this);
  }
  validate(t2, e) {
    return void 0 === e && (e = {}), U(t2, this, e);
  }
};
function R(t2, e) {
  const n = U(t2, e, { coerce: true });
  if (n[0])
    throw n[0];
  return n[1];
}
function V(t2, e) {
  return !U(t2, e)[0];
}
function U(t2, e, n) {
  void 0 === n && (n = {});
  const r = D(t2, e, n), o = function(t3) {
    const { done: e2, value: n2 } = t3.next();
    return e2 ? void 0 : n2;
  }(r);
  if (o[0]) {
    return [new T(o[0], function* () {
      for (const t3 of r)
        t3[0] && (yield t3[0]);
    }), void 0];
  }
  return [void 0, o[1]];
}
function j(t2, e) {
  return new N({ type: t2, schema: null, validator: e });
}
function $(t2) {
  return new N({ type: "array", schema: t2, *entries(e) {
    if (t2 && Array.isArray(e))
      for (const [n, r] of e.entries())
        yield [n, r, t2];
  }, coercer: (t3) => Array.isArray(t3) ? t3.slice() : t3, validator: (t3) => Array.isArray(t3) || "Expected an array value, but received: " + z(t3) });
}
function K2(t2) {
  const e = z(t2), n = typeof t2;
  return new N({ type: "literal", schema: "string" === n || "number" === n || "boolean" === n ? t2 : null, validator: (n2) => n2 === t2 || "Expected the literal `" + e + "`, but received: " + z(n2) });
}
function q(t2) {
  return new N({ ...t2, validator: (e, n) => null === e || t2.validator(e, n), refiner: (e, n) => null === e || t2.refiner(e, n) });
}
function F() {
  return j("number", (t2) => "number" == typeof t2 && !isNaN(t2) || "Expected a number, but received: " + z(t2));
}
function W(t2) {
  return new N({ ...t2, validator: (e, n) => void 0 === e || t2.validator(e, n), refiner: (e, n) => void 0 === e || t2.refiner(e, n) });
}
function G() {
  return j("string", (t2) => "string" == typeof t2 || "Expected a string, but received: " + z(t2));
}
function H(t2) {
  const e = Object.keys(t2);
  return new N({ type: "type", schema: t2, *entries(n) {
    if (C(n))
      for (const r of e)
        yield [r, n[r], t2[r]];
  }, validator: (t3) => C(t3) || "Expected an object, but received: " + z(t3) });
}
function J(t2) {
  const e = t2.map((t3) => t3.type).join(" | ");
  return new N({ type: "union", schema: null, coercer: (e2, n) => (t2.find((t3) => {
    const [n2] = t3.validate(e2, { coerce: true });
    return !n2;
  }) || Z()).coercer(e2, n), validator(n, r) {
    const o = [];
    for (const e2 of t2) {
      const [...t3] = D(n, e2, r), [i] = t3;
      if (!i[0])
        return [];
      for (const [e3] of t3)
        e3 && o.push(e3);
    }
    return ["Expected the value to satisfy a union of `" + e + "`, but received: " + z(n), ...o];
  } });
}
function Z() {
  return j("unknown", () => true);
}
async function X(t2, e, n) {
  if (e.length <= 99)
    return await Q(t2, e, n);
  {
    const r = function(t3, e2) {
      return Array.apply(0, new Array(Math.ceil(t3.length / e2))).map((n2, r2) => t3.slice(r2 * e2, (r2 + 1) * e2));
    }(e, 99);
    return (await Promise.all(r.map((e2) => Q(t2, e2, n)))).flat();
  }
}
async function Q(t2, e, n) {
  const r = null != n ? n : t2.commitment;
  return (await t2.getMultipleAccountsInfo(e, r)).map((t3, n2) => null === t3 ? null : { publicKey: e[n2], account: t3 });
}
async function Y(t2, e, n, r, i) {
  n && n.length > 0 && e.sign(...n);
  const s = e._compile(), a = s.serialize(), c = e._serialize(a).toString("base64"), u2 = { encoding: "base64", commitment: null != r ? r : t2.commitment };
  if (i) {
    const t3 = (Array.isArray(i) ? i : s.nonProgramIds()).map((t4) => t4.toBase58());
    u2.accounts = { encoding: "base64", addresses: t3 };
  }
  n && (u2.sigVerify = true);
  const d2 = [c, u2], l2 = R(await t2._rpcRequest("simulateTransaction", d2), rt);
  if ("error" in l2) {
    let t3;
    if ("data" in l2.error && (t3 = l2.error.data.logs, t3 && Array.isArray(t3))) {
      const e2 = "\n    ", n2 = e2 + t3.join(e2);
      console.error(l2.error.message, n2);
    }
    throw new SendTransactionError("failed to simulate transaction: " + l2.error.message, t3);
  }
  return l2.result;
}
function tt(t2) {
  return function(t3, e, n) {
    return new N({ ...t3, coercer: (r, o) => V(r, e) ? t3.coercer(n(r, o), o) : t3.coercer(r, o) });
  }(nt(t2), et, (e) => "error" in e ? e : { ...e, result: R(e.result, t2) });
}
var et = nt(Z());
function nt(t2) {
  return J([H({ jsonrpc: K2("2.0"), id: G(), result: t2 }), H({ jsonrpc: K2("2.0"), id: G(), error: H({ code: Z(), message: G(), data: W(j("any", () => true)) }) })]);
}
var rt = (ot = H({ err: q(J([H({}), G()])), logs: q($(G())), accounts: W(q($(q(H({ executable: j("boolean", (t2) => "boolean" == typeof t2), owner: G(), lamports: F(), data: $(G()), rentEpoch: W(F()) }))))), unitsConsumed: W(F()) }), tt(H({ context: H({ slot: F() }), value: ot })));
var ot;
var it = Object.freeze({ __proto__: null, invoke: async function(t2, e, o, i) {
  t2 = L(t2), i || (i = lt());
  const s = new Transaction();
  if (s.add(new TransactionInstruction({ programId: t2, keys: null != e ? e : [], data: o })), void 0 === i.sendAndConfirm)
    throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
  return await i.sendAndConfirm(s, []);
}, getMultipleAccounts: X, simulateTransaction: Y });
var st = class {
  constructor(t2, e, n) {
    this.connection = t2, this.wallet = e, this.opts = n, this.publicKey = e.publicKey;
  }
  static defaultOptions() {
    return { preflightCommitment: "processed", commitment: "processed" };
  }
  static local(t2, e) {
    throw new Error("Provider local is not available on browser.");
  }
  static env() {
    throw new Error("Provider env is not available on browser.");
  }
  async sendAndConfirm(t2, e, n) {
    var r;
    void 0 === n && (n = this.opts), t2.feePayer = this.wallet.publicKey, t2.recentBlockhash = (await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash, t2 = await this.wallet.signTransaction(t2), (null != e ? e : []).forEach((e2) => {
      t2.partialSign(e2);
    });
    const i = t2.serialize();
    try {
      return await ct(this.connection, i, n);
    } catch (e2) {
      if (e2 instanceof ut) {
        const n2 = await this.connection.getTransaction(_(t2.signature), { commitment: "confirmed" });
        if (n2) {
          const t3 = null === (r = n2.meta) || void 0 === r ? void 0 : r.logMessages;
          throw t3 ? new SendTransactionError(e2.message, t3) : e2;
        }
        throw e2;
      }
      throw e2;
    }
  }
  async sendAll(t2, e) {
    void 0 === e && (e = this.opts);
    const n = await this.connection.getRecentBlockhash(e.preflightCommitment);
    let r = t2.map((t3) => {
      var e2;
      let r2 = t3.tx, o2 = null !== (e2 = t3.signers) && void 0 !== e2 ? e2 : [];
      return r2.feePayer = this.wallet.publicKey, r2.recentBlockhash = n.blockhash, o2.forEach((t4) => {
        r2.partialSign(t4);
      }), r2;
    });
    const o = await this.wallet.signAllTransactions(r), i = [];
    for (let t3 = 0; t3 < r.length; t3 += 1) {
      const n2 = o[t3].serialize();
      i.push(await ct(this.connection, n2, e));
    }
    return i;
  }
  async simulate(t2, e, n, r) {
    t2.feePayer = this.wallet.publicKey, t2.recentBlockhash = (await this.connection.getLatestBlockhash(null != n ? n : this.connection.commitment)).blockhash, t2 = await this.wallet.signTransaction(t2);
    const o = await Y(this.connection, t2, e, n, r);
    if (o.value.err)
      throw new at(o.value);
    return o.value;
  }
};
var at = class extends Error {
  constructor(t2, e) {
    super(e), this.simulationResponse = t2;
  }
};
async function ct(t2, e, n) {
  const r = n && { skipPreflight: n.skipPreflight, preflightCommitment: n.preflightCommitment || n.commitment }, o = await t2.sendRawTransaction(e, r), i = (await t2.confirmTransaction(o, n && n.commitment)).value;
  if (i.err)
    throw new ut(`Raw transaction ${o} failed (${JSON.stringify(i)})`);
  return o;
}
var ut = class extends Error {
  constructor(t2) {
    super(t2);
  }
};
function dt(t2) {
  ht = t2;
}
function lt() {
  return null === ht ? st.local() : ht;
}
var ht = null;
var pt = /* @__PURE__ */ new Set(["anchor-deprecated-state", "debug-logs"]);
var ft = /* @__PURE__ */ new Map();
function mt(t2) {
  return void 0 !== ft.get(t2);
}
var yt = Object.freeze({ __proto__: null, set: function(t2) {
  if (!pt.has(t2))
    throw new Error("Invalid feature");
  ft.set(t2, true);
}, isSet: mt });
var gt = class extends Error {
  constructor(t2) {
    super(t2), this.name = "IdlError";
  }
};
var wt = class {
  constructor(t2) {
    this.stack = t2;
  }
  static parse(t2) {
    var n;
    const r = /^Program (\w*) invoke/, o = /^Program \w* success/, i = [];
    for (let s = 0; s < t2.length; s++) {
      if (o.exec(t2[s])) {
        i.pop();
        continue;
      }
      const a = null === (n = r.exec(t2[s])) || void 0 === n ? void 0 : n[1];
      a && i.push(new PublicKey(a));
    }
    return new wt(i);
  }
};
var vt = class extends Error {
  constructor(t2, e, n, r, o, i) {
    super(n.join("\n").replace("Program log: ", "")), this.errorLogs = n, this.logs = r, this.error = { errorCode: t2, errorMessage: e, comparedValues: i, origin: o }, this._programErrorStack = wt.parse(r);
  }
  static parse(t2) {
    if (!t2)
      return null;
    const n = t2.findIndex((t3) => t3.startsWith("Program log: AnchorError"));
    if (-1 === n)
      return null;
    const r = t2[n], o = [r];
    let i;
    if (n + 1 < t2.length) {
      if ("Program log: Left:" === t2[n + 1]) {
        const r2 = /^Program log: (.*)$/, s2 = r2.exec(t2[n + 2])[1], a2 = r2.exec(t2[n + 4])[1];
        i = [new PublicKey(s2), new PublicKey(a2)], o.push(...t2.slice(n + 1, n + 5));
      } else if (t2[n + 1].startsWith("Program log: Left:")) {
        const e = /^Program log: (Left|Right): (.*)$/, r2 = e.exec(t2[n + 1])[2], s2 = e.exec(t2[n + 2])[2];
        o.push(...t2.slice(n + 1, n + 3)), i = [r2, s2];
      }
    }
    const s = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r), a = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r), c = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(r);
    if (s) {
      const [e, n2, r2] = s.slice(1, 4), a2 = { code: e, number: parseInt(n2) };
      return new vt(a2, r2, o, t2, void 0, i);
    }
    if (a) {
      const [e, n2, r2, s2, c2] = a.slice(1, 6), u2 = { code: r2, number: parseInt(s2) }, d2 = { file: e, line: parseInt(n2) };
      return new vt(u2, c2, o, t2, d2, i);
    }
    if (c) {
      const [e, n2, r2, s2] = c.slice(1, 5), a2 = e, u2 = { code: n2, number: parseInt(r2) };
      return new vt(u2, s2, o, t2, a2, i);
    }
    return null;
  }
  get program() {
    return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    return this._programErrorStack.stack;
  }
  toString() {
    return this.message;
  }
};
var bt = class extends Error {
  constructor(t2, e, n) {
    super(), this.code = t2, this.msg = e, this.logs = n, n && (this._programErrorStack = wt.parse(n));
  }
  static parse(t2, e) {
    const n = t2.toString();
    let r, o;
    if (n.includes("custom program error:")) {
      let t3 = n.split("custom program error: ");
      if (2 !== t3.length)
        return null;
      r = t3[1];
    } else {
      const t3 = n.match(/"Custom":([0-9]+)}/g);
      if (!t3 || t3.length > 1)
        return null;
      r = t3[0].match(/([0-9]+)/g)[0];
    }
    try {
      o = parseInt(r);
    } catch (t3) {
      return null;
    }
    let i = e.get(o);
    return void 0 !== i ? new bt(o, i, t2.logs) : (i = St.get(o), void 0 !== i ? new bt(o, i, t2.logs) : null);
  }
  get program() {
    var t2;
    return null === (t2 = this._programErrorStack) || void 0 === t2 ? void 0 : t2.stack[this._programErrorStack.stack.length - 1];
  }
  get programErrorStack() {
    var t2;
    return null === (t2 = this._programErrorStack) || void 0 === t2 ? void 0 : t2.stack;
  }
  toString() {
    return this.msg;
  }
};
function At(t2, e) {
  mt("debug-logs") && console.log("Translating error:", t2);
  const n = vt.parse(t2.logs);
  if (n)
    return n;
  const r = bt.parse(t2, e);
  if (r)
    return r;
  if (t2.logs) {
    const e2 = { get: function(e3, n2) {
      return "programErrorStack" === n2 ? e3.programErrorStack.stack : "program" === n2 ? e3.programErrorStack.stack[t2.programErrorStack.stack.length - 1] : Reflect.get(...arguments);
    } };
    return t2.programErrorStack = wt.parse(t2.logs), new Proxy(t2, e2);
  }
  return t2;
}
var _t = { InstructionMissing: 100, InstructionFallbackNotFound: 101, InstructionDidNotDeserialize: 102, InstructionDidNotSerialize: 103, IdlInstructionStub: 1e3, IdlInstructionInvalidProgram: 1001, ConstraintMut: 2e3, ConstraintHasOne: 2001, ConstraintSigner: 2002, ConstraintRaw: 2003, ConstraintOwner: 2004, ConstraintRentExempt: 2005, ConstraintSeeds: 2006, ConstraintExecutable: 2007, ConstraintState: 2008, ConstraintAssociated: 2009, ConstraintAssociatedInit: 2010, ConstraintClose: 2011, ConstraintAddress: 2012, ConstraintZero: 2013, ConstraintTokenMint: 2014, ConstraintTokenOwner: 2015, ConstraintMintMintAuthority: 2016, ConstraintMintFreezeAuthority: 2017, ConstraintMintDecimals: 2018, ConstraintSpace: 2019, RequireViolated: 2500, RequireEqViolated: 2501, RequireKeysEqViolated: 2502, RequireNeqViolated: 2503, RequireKeysNeqViolated: 2504, RequireGtViolated: 2505, RequireGteViolated: 2506, AccountDiscriminatorAlreadySet: 3e3, AccountDiscriminatorNotFound: 3001, AccountDiscriminatorMismatch: 3002, AccountDidNotDeserialize: 3003, AccountDidNotSerialize: 3004, AccountNotEnoughKeys: 3005, AccountNotMutable: 3006, AccountOwnedByWrongProgram: 3007, InvalidProgramId: 3008, InvalidProgramExecutable: 3009, AccountNotSigner: 3010, AccountNotSystemOwned: 3011, AccountNotInitialized: 3012, AccountNotProgramData: 3013, AccountNotAssociatedTokenAccount: 3014, AccountSysvarMismatch: 3015, AccountReallocExceedsLimit: 3016, AccountDuplicateReallocs: 3017, StateInvalidAddress: 4e3, DeclaredProgramIdMismatch: 4100, Deprecated: 5e3 };
var St = /* @__PURE__ */ new Map([[_t.InstructionMissing, "8 byte instruction identifier not provided"], [_t.InstructionFallbackNotFound, "Fallback functions are not supported"], [_t.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"], [_t.InstructionDidNotSerialize, "The program could not serialize the given instruction"], [_t.IdlInstructionStub, "The program was compiled without idl instructions"], [_t.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"], [_t.ConstraintMut, "A mut constraint was violated"], [_t.ConstraintHasOne, "A has_one constraint was violated"], [_t.ConstraintSigner, "A signer constraint was violated"], [_t.ConstraintRaw, "A raw constraint was violated"], [_t.ConstraintOwner, "An owner constraint was violated"], [_t.ConstraintRentExempt, "A rent exemption constraint was violated"], [_t.ConstraintSeeds, "A seeds constraint was violated"], [_t.ConstraintExecutable, "An executable constraint was violated"], [_t.ConstraintState, "A state constraint was violated"], [_t.ConstraintAssociated, "An associated constraint was violated"], [_t.ConstraintAssociatedInit, "An associated init constraint was violated"], [_t.ConstraintClose, "A close constraint was violated"], [_t.ConstraintAddress, "An address constraint was violated"], [_t.ConstraintZero, "Expected zero account discriminant"], [_t.ConstraintTokenMint, "A token mint constraint was violated"], [_t.ConstraintTokenOwner, "A token owner constraint was violated"], [_t.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"], [_t.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"], [_t.ConstraintMintDecimals, "A mint decimals constraint was violated"], [_t.ConstraintSpace, "A space constraint was violated"], [_t.RequireViolated, "A require expression was violated"], [_t.RequireEqViolated, "A require_eq expression was violated"], [_t.RequireKeysEqViolated, "A require_keys_eq expression was violated"], [_t.RequireNeqViolated, "A require_neq expression was violated"], [_t.RequireKeysNeqViolated, "A require_keys_neq expression was violated"], [_t.RequireGtViolated, "A require_gt expression was violated"], [_t.RequireGteViolated, "A require_gte expression was violated"], [_t.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"], [_t.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"], [_t.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"], [_t.AccountDidNotDeserialize, "Failed to deserialize the account"], [_t.AccountDidNotSerialize, "Failed to serialize the account"], [_t.AccountNotEnoughKeys, "Not enough account keys given to the instruction"], [_t.AccountNotMutable, "The given account is not mutable"], [_t.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"], [_t.InvalidProgramId, "Program ID was not as expected"], [_t.InvalidProgramExecutable, "Program account is not executable"], [_t.AccountNotSigner, "The given account did not sign"], [_t.AccountNotSystemOwned, "The given account is not owned by the system program"], [_t.AccountNotInitialized, "The program expected this account to be already initialized"], [_t.AccountNotProgramData, "The given account is not a program data account"], [_t.AccountNotAssociatedTokenAccount, "The given account is not the associated token account"], [_t.AccountSysvarMismatch, "The given public key does not match the required sysvar"], [_t.AccountReallocExceedsLimit, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"], [_t.AccountDuplicateReallocs, "The account was duplicated for more than one reallocation"], [_t.StateInvalidAddress, "The given state account does not have the correct address"], [_t.DeclaredProgramIdMismatch, "The declared program id does not match the actual program id"], [_t.Deprecated, "The API being used is deprecated and should no longer be used"]]);
var Et = function() {
  return Et = Object.assign || function(t2) {
    for (var e, n = 1, r = arguments.length; n < r; n++)
      for (var o in e = arguments[n])
        Object.prototype.hasOwnProperty.call(e, o) && (t2[o] = e[o]);
    return t2;
  }, Et.apply(this, arguments);
};
function It(t2) {
  return t2.toLowerCase();
}
var kt = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];
var Mt = /[^A-Z0-9]+/gi;
function xt(t2, e, n) {
  return e instanceof RegExp ? t2.replace(e, n) : e.reduce(function(t3, e2) {
    return t3.replace(e2, n);
  }, t2);
}
function Pt(t2, e) {
  return void 0 === e && (e = {}), function(t3, e2) {
    void 0 === e2 && (e2 = {});
    for (var n = e2.splitRegexp, r = void 0 === n ? kt : n, o = e2.stripRegexp, i = void 0 === o ? Mt : o, s = e2.transform, a = void 0 === s ? It : s, c = e2.delimiter, u2 = void 0 === c ? " " : c, d2 = xt(xt(t3, r, "$1\0$2"), i, "\0"), l2 = 0, h2 = d2.length; "\0" === d2.charAt(l2); )
      l2++;
    for (; "\0" === d2.charAt(h2 - 1); )
      h2--;
    return d2.slice(l2, h2).split("\0").map(a).join(u2);
  }(t2, Et({ delimiter: "." }, e));
}
var Lt = class {
  static fieldLayout(t2, e) {
    const n = void 0 !== t2.name ? (0, import_camelcase.default)(t2.name) : void 0;
    switch (t2.type) {
      case "bool":
        return f.bool(n);
      case "u8":
        return f.u8(n);
      case "i8":
        return f.i8(n);
      case "u16":
        return f.u16(n);
      case "i16":
        return f.i16(n);
      case "u32":
        return f.u32(n);
      case "i32":
        return f.i32(n);
      case "f32":
        return f.f32(n);
      case "u64":
        return f.u64(n);
      case "i64":
        return f.i64(n);
      case "f64":
        return f.f64(n);
      case "u128":
        return f.u128(n);
      case "i128":
        return f.i128(n);
      case "bytes":
        return f.vecU8(n);
      case "string":
        return f.str(n);
      case "publicKey":
        return f.publicKey(n);
      default:
        if ("vec" in t2.type)
          return f.vec(Lt.fieldLayout({ name: void 0, type: t2.type.vec }, e), n);
        if ("option" in t2.type)
          return f.option(Lt.fieldLayout({ name: void 0, type: t2.type.option }, e), n);
        if ("defined" in t2.type) {
          const r = t2.type.defined;
          if (void 0 === e)
            throw new gt("User defined types not provided");
          const o = e.filter((t3) => t3.name === r);
          if (1 !== o.length)
            throw new gt(`Type not found: ${JSON.stringify(t2)}`);
          return Lt.typeDefLayout(o[0], e, n);
        }
        if ("array" in t2.type) {
          let r = t2.type.array[0], o = t2.type.array[1], i = Lt.fieldLayout({ name: void 0, type: r }, e);
          return f.array(i, o, n);
        }
        throw new Error(`Not yet implemented: ${t2}`);
    }
  }
  static typeDefLayout(t2, e = [], n) {
    if ("struct" === t2.type.kind) {
      const r = t2.type.fields.map((t3) => Lt.fieldLayout(t3, e));
      return f.struct(r, n);
    }
    if ("enum" === t2.type.kind) {
      let r = t2.type.variants.map((t3) => {
        const n2 = (0, import_camelcase.default)(t3.name);
        if (void 0 === t3.fields)
          return f.struct([], n2);
        const r2 = t3.fields.map((t4) => {
          if (!t4.hasOwnProperty("name"))
            throw new Error("Tuple enum variants not yet implemented.");
          return Lt.fieldLayout(t4, e);
        });
        return f.struct(r2, n2);
      });
      return void 0 !== n ? f.rustEnum(r).replicate(n) : f.rustEnum(r, n);
    }
    throw new Error(`Unknown type kint: ${t2}`);
  }
};
var Tt = class {
  constructor(t2) {
    this.idl = t2, this.ixLayout = Tt.parseIxLayout(t2);
    const e = /* @__PURE__ */ new Map();
    t2.instructions.forEach((t3) => {
      const n = zt("global", t3.name);
      e.set(import_bs58.default.encode(n), { layout: this.ixLayout.get(t3.name), name: t3.name });
    }), t2.state && t2.state.methods.map((t3) => {
      const n = zt("state", t3.name);
      e.set(import_bs58.default.encode(n), { layout: this.ixLayout.get(t3.name), name: t3.name });
    }), this.sighashLayouts = e;
  }
  encode(t2, e) {
    return this._encode("global", t2, e);
  }
  encodeState(t2, e) {
    return this._encode("state", t2, e);
  }
  _encode(e, n, r) {
    const o = import_buffer.Buffer.alloc(1e3), i = (0, import_camelcase.default)(n), s = this.ixLayout.get(i);
    if (!s)
      throw new Error(`Unknown method: ${i}`);
    const a = s.encode(r, o), c = o.slice(0, a);
    return import_buffer.Buffer.concat([zt(e, n), c]);
  }
  static parseIxLayout(t2) {
    const e = (t2.state ? t2.state.methods : []).map((e2) => {
      let n = e2.args.map((e3) => {
        var n2, r2;
        return Lt.fieldLayout(e3, Array.from([...null !== (n2 = t2.accounts) && void 0 !== n2 ? n2 : [], ...null !== (r2 = t2.types) && void 0 !== r2 ? r2 : []]));
      });
      const r = (0, import_camelcase.default)(e2.name);
      return [r, f.struct(n, r)];
    }).concat(t2.instructions.map((e2) => {
      let n = e2.args.map((e3) => {
        var n2, r2;
        return Lt.fieldLayout(e3, Array.from([...null !== (n2 = t2.accounts) && void 0 !== n2 ? n2 : [], ...null !== (r2 = t2.types) && void 0 !== r2 ? r2 : []]));
      });
      const r = (0, import_camelcase.default)(e2.name);
      return [r, f.struct(n, r)];
    }));
    return new Map(e);
  }
  decode(e, n = "hex") {
    "string" == typeof e && (e = "hex" === n ? import_buffer.Buffer.from(e, "hex") : import_bs58.default.decode(e));
    let r = import_bs58.default.encode(e.slice(0, 8)), o = e.slice(8);
    const i = this.sighashLayouts.get(r);
    return i ? { data: i.layout.decode(o), name: i.name } : null;
  }
  format(t2, e) {
    return Ct.format(t2, e, this.idl);
  }
};
var Ct = class {
  static format(t2, e, n) {
    const r = n.instructions.filter((e2) => t2.name === e2.name)[0];
    if (void 0 === r)
      return console.error("Invalid instruction given"), null;
    const o = r.args.map((e2) => ({ name: e2.name, type: Ct.formatIdlType(e2.type), data: Ct.formatIdlData(e2, t2.data[e2.name], n.types) })), i = Ct.flattenIdlAccounts(r.accounts);
    return { args: o, accounts: e.map((t3, e2) => e2 < i.length ? { name: i[e2].name, ...t3 } : { name: void 0, ...t3 }) };
  }
  static formatIdlType(t2) {
    if ("string" == typeof t2)
      return t2;
    if ("vec" in t2)
      return `Vec<${this.formatIdlType(t2.vec)}>`;
    if ("option" in t2)
      return `Option<${this.formatIdlType(t2.option)}>`;
    if ("defined" in t2)
      return t2.defined;
    if ("array" in t2)
      return `Array<${t2.array[0]}; ${t2.array[1]}>`;
    throw new Error(`Unknown IDL type: ${t2}`);
  }
  static formatIdlData(t2, e, n) {
    if ("string" == typeof t2.type)
      return e.toString();
    if (t2.type.hasOwnProperty("vec"))
      return "[" + e.map((e2) => this.formatIdlData({ name: "", type: t2.type.vec }, e2)).join(", ") + "]";
    if (t2.type.hasOwnProperty("option"))
      return null === e ? "null" : this.formatIdlData({ name: "", type: t2.type.option }, e, n);
    if (t2.type.hasOwnProperty("defined")) {
      if (void 0 === n)
        throw new Error("User defined types not provided");
      const r = n.filter((e2) => e2.name === t2.type.defined);
      if (1 !== r.length)
        throw new Error(`Type not found: ${t2.type.defined}`);
      return Ct.formatIdlDataDefined(r[0], e, n);
    }
    return "unknown";
  }
  static formatIdlDataDefined(t2, e, n) {
    if ("struct" === t2.type.kind) {
      const r = t2.type;
      return "{ " + Object.keys(e).map((t3) => {
        const o = r.fields.filter((e2) => e2.name === t3)[0];
        if (void 0 === o)
          throw new Error("Unable to find type");
        return t3 + ": " + Ct.formatIdlData(o, e[t3], n);
      }).join(", ") + " }";
    }
    if (0 === t2.type.variants.length)
      return "{}";
    if (t2.type.variants[0].name) {
      const r = t2.type.variants, o = Object.keys(e)[0], i = e[o], s = Object.keys(i).map((t3) => {
        var e2;
        const s2 = i[t3], a2 = null === (e2 = r[o]) || void 0 === e2 ? void 0 : e2.filter((e3) => e3.name === t3)[0];
        if (void 0 === a2)
          throw new Error("Unable to find variant");
        return t3 + ": " + Ct.formatIdlData(a2, s2, n);
      }).join(", "), a = (0, import_camelcase.default)(o, { pascalCase: true });
      return 0 === s.length ? a : `${a} { ${s} }`;
    }
    return "Tuple formatting not yet implemented";
  }
  static flattenIdlAccounts(t2, e) {
    return t2.map((t3) => {
      const n = function(t4) {
        const e2 = t4.replace(/([A-Z])/g, " $1");
        return e2.charAt(0).toUpperCase() + e2.slice(1);
      }(t3.name);
      if (t3.hasOwnProperty("accounts")) {
        const r = e ? `${e} > ${n}` : n;
        return Ct.flattenIdlAccounts(t3.accounts, r);
      }
      return { ...t3, name: e ? `${e} > ${n}` : n };
    }).flat();
  }
};
function zt(e, n) {
  var r;
  let o = `${e}:${void 0 === r && (r = {}), Pt(n, Et({ delimiter: "_" }, r))}`;
  return import_buffer.Buffer.from(import_js_sha256.sha256.digest(o)).slice(0, 8);
}
function Bt(t2, e) {
  if ("enum" === e.type.kind) {
    let n = e.type.variants.map((e2) => void 0 === e2.fields ? 0 : e2.fields.map((e3) => {
      if ("object" != typeof e3 || !("name" in e3))
        throw new Error("Tuple enum variants not yet implemented.");
      return Ot(t2, e3.type);
    }).reduce((t3, e3) => t3 + e3));
    return Math.max(...n) + 1;
  }
  return void 0 === e.type.fields ? 0 : e.type.fields.map((e2) => Ot(t2, e2.type)).reduce((t3, e2) => t3 + e2, 0);
}
function Ot(t2, e) {
  var n, r;
  switch (e) {
    case "bool":
    case "u8":
    case "i8":
    case "bytes":
    case "string":
      return 1;
    case "i16":
    case "u16":
      return 2;
    case "u32":
    case "i32":
    case "f32":
      return 4;
    case "u64":
    case "i64":
    case "f64":
      return 8;
    case "u128":
    case "i128":
      return 16;
    case "publicKey":
      return 32;
    default:
      if ("vec" in e)
        return 1;
      if ("option" in e)
        return 1 + Ot(t2, e.option);
      if ("coption" in e)
        return 4 + Ot(t2, e.coption);
      if ("defined" in e) {
        const o = null !== (r = null === (n = t2.types) || void 0 === n ? void 0 : n.filter((t3) => t3.name === e.defined)) && void 0 !== r ? r : [];
        if (1 !== o.length)
          throw new gt(`Type not found: ${JSON.stringify(e)}`);
        return Bt(t2, o[0]);
      }
      if ("array" in e) {
        let n2 = e.array[0], r2 = e.array[1];
        return Ot(t2, n2) * r2;
      }
      throw new Error(`Invalid type ${JSON.stringify(e)}`);
  }
}
var Dt = 8;
var Nt = class {
  constructor(t2) {
    if (void 0 === t2.accounts)
      return void (this.accountLayouts = /* @__PURE__ */ new Map());
    const e = t2.accounts.map((e2) => [e2.name, Lt.typeDefLayout(e2, t2.types)]);
    this.accountLayouts = new Map(e), this.idl = t2;
  }
  async encode(e, n) {
    const r = import_buffer.Buffer.alloc(1e3), o = this.accountLayouts.get(e);
    if (!o)
      throw new Error(`Unknown account: ${e}`);
    const i = o.encode(n, r);
    let s = r.slice(0, i), a = Nt.accountDiscriminator(e);
    return import_buffer.Buffer.concat([a, s]);
  }
  decode(t2, e) {
    if (Nt.accountDiscriminator(t2).compare(e.slice(0, 8)))
      throw new Error("Invalid account discriminator");
    return this.decodeUnchecked(t2, e);
  }
  decodeUnchecked(t2, e) {
    const n = e.slice(8), r = this.accountLayouts.get(t2);
    if (!r)
      throw new Error(`Unknown account: ${t2}`);
    return r.decode(n);
  }
  memcmp(e, n) {
    const r = Nt.accountDiscriminator(e);
    return { offset: 0, bytes: import_bs58.default.encode(n ? import_buffer.Buffer.concat([r, n]) : r) };
  }
  size(t2) {
    var e;
    return 8 + (null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0);
  }
  static accountDiscriminator(e) {
    return import_buffer.Buffer.from(import_js_sha256.sha256.digest(`account:${(0, import_camelcase.default)(e, { pascalCase: true })}`)).slice(0, 8);
  }
};
var Rt = class {
  constructor(t2) {
    if (void 0 === t2.events)
      return void (this.layouts = /* @__PURE__ */ new Map());
    const e = t2.events.map((e2) => {
      let n = { name: e2.name, type: { kind: "struct", fields: e2.fields.map((t3) => ({ name: t3.name, type: t3.type })) } };
      return [e2.name, Lt.typeDefLayout(n, t2.types)];
    });
    this.layouts = new Map(e), this.discriminators = new Map(void 0 === t2.events ? [] : t2.events.map((t3) => [l.fromByteArray(Vt(t3.name)), t3.name]));
  }
  decode(e) {
    let n;
    try {
      n = import_buffer.Buffer.from(l.toByteArray(e));
    } catch (t2) {
      return null;
    }
    const r = l.fromByteArray(n.slice(0, 8)), o = this.discriminators.get(r);
    if (void 0 === o)
      return null;
    const i = this.layouts.get(o);
    if (!i)
      throw new Error(`Unknown event: ${o}`);
    return { data: i.decode(n.slice(8)), name: o };
  }
};
function Vt(e) {
  return import_buffer.Buffer.from(import_js_sha256.sha256.digest(`event:${e}`)).slice(0, 8);
}
var Ut = class {
  constructor(t2) {
    if (void 0 === t2.state)
      throw new Error("Idl state not defined.");
    this.layout = Lt.typeDefLayout(t2.state.struct, t2.types);
  }
  async encode(e, n) {
    const r = import_buffer.Buffer.alloc(1e3), o = this.layout.encode(n, r), i = await jt(e), s = r.slice(0, o);
    return import_buffer.Buffer.concat([i, s]);
  }
  decode(t2) {
    const e = t2.slice(8);
    return this.layout.decode(e);
  }
};
async function jt(e) {
  let n = mt("anchor-deprecated-state") ? "account" : "state";
  return import_buffer.Buffer.from(import_js_sha256.sha256.digest(`${n}:${e}`)).slice(0, 8);
}
var $t = class {
  constructor(t2) {
    if (void 0 === t2.types)
      return void (this.typeLayouts = /* @__PURE__ */ new Map());
    const e = t2.types.map((e2) => [e2.name, Lt.typeDefLayout(e2, t2.types)]);
    this.typeLayouts = new Map(e), this.idl = t2;
  }
  encode(e, n) {
    const r = import_buffer.Buffer.alloc(1e3), o = this.typeLayouts.get(e);
    if (!o)
      throw new Error(`Unknown type: ${e}`);
    const i = o.encode(n, r);
    return r.slice(0, i);
  }
  decode(t2, e) {
    const n = this.typeLayouts.get(t2);
    if (!n)
      throw new Error(`Unknown type: ${t2}`);
    return n.decode(e);
  }
};
var Kt = class {
  constructor(t2) {
    this.instruction = new Tt(t2), this.accounts = new Nt(t2), this.events = new Rt(t2), t2.state && (this.state = new Ut(t2)), this.types = new $t(t2);
  }
};
var qt = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function Ft(t2) {
  return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
}
var Wt = class {
  constructor(t2, e) {
    if (!Number.isInteger(t2))
      throw new TypeError("span must be an integer");
    this.span = t2, this.property = e;
  }
  makeDestinationObject() {
    return {};
  }
  decode(t2, e) {
    throw new Error("Layout is abstract");
  }
  encode(t2, e, n) {
    throw new Error("Layout is abstract");
  }
  getSpan(t2, e) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  replicate(t2) {
    const e = Object.create(this.constructor.prototype);
    return Object.assign(e, this), e.property = t2, e;
  }
  fromArray(t2) {
  }
};
var Gt = Wt;
var Ht = class extends Wt {
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
};
var Jt = class extends Ht {
  constructor(t2, e, n) {
    if (!(t2 instanceof Wt))
      throw new TypeError("layout must be a Layout");
    if (void 0 === e)
      e = 0;
    else if (!Number.isInteger(e))
      throw new TypeError("offset must be integer or undefined");
    super(t2.span, n || t2.property), this.layout = t2, this.offset = e;
  }
  isCount() {
    return this.layout instanceof Zt || this.layout instanceof Xt;
  }
  decode(t2, e) {
    return void 0 === e && (e = 0), this.layout.decode(t2, e + this.offset);
  }
  encode(t2, e, n) {
    return void 0 === n && (n = 0), this.layout.encode(t2, e, n + this.offset);
  }
};
var Zt = class extends Wt {
  constructor(t2, e) {
    if (super(t2, e), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t2, e) {
    return void 0 === e && (e = 0), t2.readUIntLE(e, this.span);
  }
  encode(t2, e, n) {
    return void 0 === n && (n = 0), e.writeUIntLE(t2, n, this.span), this.span;
  }
};
var Xt = class extends Wt {
  constructor(t2, e) {
    if (super(t2, e), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  decode(t2, e) {
    return void 0 === e && (e = 0), t2.readUIntBE(e, this.span);
  }
  encode(t2, e, n) {
    return void 0 === n && (n = 0), e.writeUIntBE(t2, n, this.span), this.span;
  }
};
var Qt = Math.pow(2, 32);
function Yt(t2) {
  const e = Math.floor(t2 / Qt);
  return { hi32: e, lo32: t2 - e * Qt };
}
function te(t2, e) {
  return t2 * Qt + e;
}
var ee = class extends Wt {
  constructor(t2) {
    super(8, t2);
  }
  decode(t2, e) {
    void 0 === e && (e = 0);
    const n = t2.readUInt32LE(e);
    return te(t2.readUInt32LE(e + 4), n);
  }
  encode(t2, e, n) {
    void 0 === n && (n = 0);
    const r = Yt(t2);
    return e.writeUInt32LE(r.lo32, n), e.writeUInt32LE(r.hi32, n + 4), 8;
  }
};
var ne = class extends Wt {
  constructor(t2) {
    super(8, t2);
  }
  decode(t2, e) {
    void 0 === e && (e = 0);
    const n = t2.readUInt32LE(e);
    return te(t2.readInt32LE(e + 4), n);
  }
  encode(t2, e, n) {
    void 0 === n && (n = 0);
    const r = Yt(t2);
    return e.writeUInt32LE(r.lo32, n), e.writeInt32LE(r.hi32, n + 4), 8;
  }
};
var re = class extends Wt {
  constructor(t2, e, n) {
    if (!Array.isArray(t2) || !t2.reduce((t3, e2) => t3 && e2 instanceof Wt, true))
      throw new TypeError("fields must be array of Layout instances");
    "boolean" == typeof e && void 0 === n && (n = e, e = void 0);
    for (const e2 of t2)
      if (0 > e2.span && void 0 === e2.property)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let r = -1;
    try {
      r = t2.reduce((t3, e2) => t3 + e2.getSpan(), 0);
    } catch (t3) {
    }
    super(r, e), this.fields = t2, this.decodePrefixes = !!n;
  }
  getSpan(t2, e) {
    if (0 <= this.span)
      return this.span;
    void 0 === e && (e = 0);
    let n = 0;
    try {
      n = this.fields.reduce((n2, r) => {
        const o = r.getSpan(t2, e);
        return e += o, n2 + o;
      }, 0);
    } catch (t3) {
      throw new RangeError("indeterminate span");
    }
    return n;
  }
  decode(t2, e) {
    void 0 === e && (e = 0);
    const n = this.makeDestinationObject();
    for (const r of this.fields)
      if (void 0 !== r.property && (n[r.property] = r.decode(t2, e)), e += r.getSpan(t2, e), this.decodePrefixes && t2.length === e)
        break;
    return n;
  }
  encode(t2, e, n) {
    void 0 === n && (n = 0);
    const r = n;
    let o = 0, i = 0;
    for (const r2 of this.fields) {
      let s = r2.span;
      if (i = 0 < s ? s : 0, void 0 !== r2.property) {
        const o2 = t2[r2.property];
        void 0 !== o2 && (i = r2.encode(o2, e, n), 0 > s && (s = r2.getSpan(e, n)));
      }
      o = n, n += s;
    }
    return o + i - r;
  }
  fromArray(t2) {
    const e = this.makeDestinationObject();
    for (const n of this.fields)
      void 0 !== n.property && 0 < t2.length && (e[n.property] = t2.shift());
    return e;
  }
  layoutFor(t2) {
    if ("string" != typeof t2)
      throw new TypeError("property must be string");
    for (const e of this.fields)
      if (e.property === t2)
        return e;
  }
  offsetOf(t2) {
    if ("string" != typeof t2)
      throw new TypeError("property must be string");
    let e = 0;
    for (const n of this.fields) {
      if (n.property === t2)
        return e;
      0 > n.span ? e = -1 : 0 <= e && (e += n.span);
    }
  }
};
var oe = class {
  constructor(t2) {
    this.property = t2;
  }
  decode() {
    throw new Error("UnionDiscriminator is abstract");
  }
  encode() {
    throw new Error("UnionDiscriminator is abstract");
  }
};
var ie = class extends oe {
  constructor(t2, e) {
    if (!(t2 instanceof Ht && t2.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(e || t2.property || "variant"), this.layout = t2;
  }
  decode(t2, e) {
    return this.layout.decode(t2, e);
  }
  encode(t2, e, n) {
    return this.layout.encode(t2, e, n);
  }
};
var se = class extends Wt {
  constructor(t2, e, n) {
    const r = t2 instanceof Zt || t2 instanceof Xt;
    if (r)
      t2 = new ie(new Jt(t2));
    else if (t2 instanceof Ht && t2.isCount())
      t2 = new ie(t2);
    else if (!(t2 instanceof oe))
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (void 0 === e && (e = null), !(null === e || e instanceof Wt))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (null !== e) {
      if (0 > e.span)
        throw new Error("defaultLayout must have constant span");
      void 0 === e.property && (e = e.replicate("content"));
    }
    let o = -1;
    e && (o = e.span, 0 <= o && r && (o += t2.layout.span)), super(o, n), this.discriminator = t2, this.usesPrefixDiscriminator = r, this.defaultLayout = e, this.registry = {};
    let i = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(t3) {
      return i(t3);
    }, this.configGetSourceVariant = function(t3) {
      i = t3.bind(this);
    };
  }
  getSpan(t2, e) {
    if (0 <= this.span)
      return this.span;
    void 0 === e && (e = 0);
    const n = this.getVariant(t2, e);
    if (!n)
      throw new Error("unable to determine span for unrecognized variant");
    return n.getSpan(t2, e);
  }
  defaultGetSourceVariant(t2) {
    if (t2.hasOwnProperty(this.discriminator.property)) {
      if (this.defaultLayout && t2.hasOwnProperty(this.defaultLayout.property))
        return;
      const e = this.registry[t2[this.discriminator.property]];
      if (e && (!e.layout || t2.hasOwnProperty(e.property)))
        return e;
    } else
      for (const e in this.registry) {
        const n = this.registry[e];
        if (t2.hasOwnProperty(n.property))
          return n;
      }
    throw new Error("unable to infer src variant");
  }
  decode(t2, e) {
    let n;
    void 0 === e && (e = 0);
    const r = this.discriminator, o = r.decode(t2, e);
    let i = this.registry[o];
    if (void 0 === i) {
      let s = 0;
      i = this.defaultLayout, this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = o, n[i.property] = this.defaultLayout.decode(t2, e + s);
    } else
      n = i.decode(t2, e);
    return n;
  }
  encode(t2, e, n) {
    void 0 === n && (n = 0);
    const r = this.getSourceVariant(t2);
    if (void 0 === r) {
      const r2 = this.discriminator, o = this.defaultLayout;
      let i = 0;
      return this.usesPrefixDiscriminator && (i = r2.layout.span), r2.encode(t2[r2.property], e, n), i + o.encode(t2[o.property], e, n + i);
    }
    return r.encode(t2, e, n);
  }
  addVariant(t2, e, n) {
    const r = new ae(this, t2, e, n);
    return this.registry[t2] = r, r;
  }
  getVariant(t2, e) {
    let n = t2;
    return Buffer.isBuffer(t2) && (void 0 === e && (e = 0), n = this.discriminator.decode(t2, e)), this.registry[n];
  }
};
var ae = class extends Wt {
  constructor(t2, e, n, r) {
    if (!(t2 instanceof se))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(e) || 0 > e)
      throw new TypeError("variant must be a (non-negative) integer");
    if ("string" == typeof n && void 0 === r && (r = n, n = null), n) {
      if (!(n instanceof Wt))
        throw new TypeError("layout must be a Layout");
      if (null !== t2.defaultLayout && 0 <= n.span && n.span > t2.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if ("string" != typeof r)
        throw new TypeError("variant must have a String property");
    }
    let o = t2.span;
    0 > t2.span && (o = n ? n.span : 0, 0 <= o && t2.usesPrefixDiscriminator && (o += t2.discriminator.layout.span)), super(o, r), this.union = t2, this.variant = e, this.layout = n || null;
  }
  getSpan(t2, e) {
    if (0 <= this.span)
      return this.span;
    void 0 === e && (e = 0);
    let n = 0;
    return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), n + this.layout.getSpan(t2, e + n);
  }
  decode(t2, e) {
    const n = this.makeDestinationObject();
    if (void 0 === e && (e = 0), this !== this.union.getVariant(t2, e))
      throw new Error("variant mismatch");
    let r = 0;
    return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(t2, e + r) : this.property ? n[this.property] = true : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n;
  }
  encode(t2, e, n) {
    void 0 === n && (n = 0);
    let r = 0;
    if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !t2.hasOwnProperty(this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, e, n);
    let o = r;
    if (this.layout && (this.layout.encode(t2[this.property], e, n + r), o += this.layout.getSpan(e, n + r), 0 <= this.union.span && o > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return o;
  }
  fromArray(t2) {
    if (this.layout)
      return this.layout.fromArray(t2);
  }
};
var ce = class extends Wt {
  constructor(t2, e) {
    if (!(t2 instanceof Ht && t2.isCount() || Number.isInteger(t2) && 0 <= t2))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let n = -1;
    t2 instanceof Ht || (n = t2), super(n, e), this.length = t2;
  }
  getSpan(t2, e) {
    let n = this.span;
    return 0 > n && (n = this.length.decode(t2, e)), n;
  }
  decode(t2, e) {
    void 0 === e && (e = 0);
    let n = this.span;
    return 0 > n && (n = this.length.decode(t2, e)), t2.slice(e, e + n);
  }
  encode(t2, e, n) {
    let r = this.length;
    if (this.length instanceof Ht && (r = t2.length), !Buffer.isBuffer(t2) || r !== t2.length)
      throw new TypeError((o = "Blob.encode", ((i = this).property ? o + "[" + i.property + "]" : o) + " requires (length " + r + ") Buffer as src"));
    var o, i;
    if (n + r > e.length)
      throw new RangeError("encoding overruns Buffer");
    return e.write(t2.toString("hex"), n, r, "hex"), this.length instanceof Ht && this.length.encode(r, e, n), r;
  }
};
var ue = (t2, e, n) => new Jt(t2, e, n);
var de = (t2) => new Zt(1, t2);
var le = (t2) => new Zt(4, t2);
var he = (t2) => new ee(t2);
var pe = (t2) => new ne(t2);
var fe = (t2, e, n) => new re(t2, e, n);
var me = (t2, e, n) => new se(t2, e, n);
var ye = (t2, e) => new ce(t2, e);
var ge = class {
  constructor(t2) {
  }
  encode(t2, n) {
    switch ((0, import_camelcase.default)(t2)) {
      case "initializeMint":
        return function({ decimals: t3, mintAuthority: n2, freezeAuthority: r }) {
          return be({ initializeMint: { decimals: t3, mintAuthority: n2.toBuffer(), freezeAuthorityOption: !!r, freezeAuthority: (r || PublicKey.default).toBuffer() } });
        }(n);
      case "initializeAccount":
        return be({ initializeAccount: {} });
      case "initializeMultisig":
        return function({ m: t3 }) {
          return be({ initializeMultisig: { m: t3 } });
        }(n);
      case "transfer":
        return function({ amount: t3 }) {
          return be({ transfer: { amount: t3 } });
        }(n);
      case "approve":
        return function({ amount: t3 }) {
          return be({ approve: { amount: t3 } });
        }(n);
      case "revoke":
        return be({ revoke: {} });
      case "setAuthority":
        return function({ authorityType: t3, newAuthority: e }) {
          return be({ setAuthority: { authorityType: t3, newAuthority: e } });
        }(n);
      case "mintTo":
        return function({ amount: t3 }) {
          return be({ mintTo: { amount: t3 } });
        }(n);
      case "burn":
        return function({ amount: t3 }) {
          return be({ burn: { amount: t3 } });
        }(n);
      case "closeAccount":
        return be({ closeAccount: {} });
      case "freezeAccount":
        return be({ freezeAccount: {} });
      case "thawAccount":
        return be({ thawAccount: {} });
      case "transferChecked":
        return function({ amount: t3, decimals: e }) {
          return be({ transferChecked: { amount: t3, decimals: e } });
        }(n);
      case "approvedChecked":
        return function({ amount: t3, decimals: e }) {
          return be({ approveChecked: { amount: t3, decimals: e } });
        }(n);
      case "mintToChecked":
        return function({ amount: t3, decimals: e }) {
          return be({ mintToChecked: { amount: t3, decimals: e } });
        }(n);
      case "burnChecked":
        return function({ amount: t3, decimals: e }) {
          return be({ burnChecked: { amount: t3, decimals: e } });
        }(n);
      case "intializeAccount2":
        return function({ authority: t3 }) {
          return be({ initilaizeAccount2: { authority: t3 } });
        }(n);
      case "syncNative":
        return be({ syncNative: {} });
      case "initializeAccount3":
        return function({ authority: t3 }) {
          return be({ initializeAccount3: { authority: t3 } });
        }(n);
      case "initializeMultisig2":
        return function({ m: t3 }) {
          return be({ initializeMultisig2: { m: t3 } });
        }(n);
      case "initializeMint2":
        return function({ decimals: t3, mintAuthority: e, freezeAuthority: n2 }) {
          return be({ encodeInitializeMint2: { decimals: t3, mintAuthority: e, freezeAuthority: n2 } });
        }(n);
      default:
        throw new Error(`Invalid instruction: ${t2}`);
    }
  }
  encodeState(t2, e) {
    throw new Error("SPL token does not have state");
  }
};
var we = me(de("instruction"));
function ve(t2) {
  return ye(32, t2);
}
function be(t2) {
  let e = Buffer.alloc(Ae), n = we.encode(t2, e);
  return e.slice(0, n);
}
we.addVariant(0, fe([de("decimals"), ye(32, "mintAuthority"), de("freezeAuthorityOption"), ve("freezeAuthority")]), "initializeMint"), we.addVariant(1, fe([]), "initializeAccount"), we.addVariant(2, fe([de("m")]), "initializeMultisig"), we.addVariant(3, fe([he("amount")]), "transfer"), we.addVariant(4, fe([he("amount")]), "approve"), we.addVariant(5, fe([]), "revoke"), we.addVariant(6, fe([de("authorityType"), de("newAuthorityOption"), ve("newAuthority")]), "setAuthority"), we.addVariant(7, fe([he("amount")]), "mintTo"), we.addVariant(8, fe([he("amount")]), "burn"), we.addVariant(9, fe([]), "closeAccount"), we.addVariant(10, fe([]), "freezeAccount"), we.addVariant(11, fe([]), "thawAccount"), we.addVariant(12, fe([he("amount"), de("decimals")]), "transferChecked"), we.addVariant(13, fe([he("amount"), de("decimals")]), "approvedChecked"), we.addVariant(14, fe([he("amount"), de("decimals")]), "mintToChecked"), we.addVariant(15, fe([he("amount"), de("decimals")]), "burnedChecked"), we.addVariant(16, fe([ve("authority")]), "InitializeAccount2"), we.addVariant(17, fe([]), "syncNative"), we.addVariant(18, fe([ve("authority")]), "initializeAccount3"), we.addVariant(19, fe([de("m")]), "initializeMultisig2"), we.addVariant(20, fe([de("decimals"), ve("mintAuthority"), de("freezeAuthorityOption"), ve("freezeAuthority")]), "initializeMint2");
var Ae = Math.max(...Object.values(we.registry).map((t2) => t2.span));
var _e = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("SPL token does not have state");
  }
  decode(t2) {
    throw new Error("SPL token does not have state");
  }
};
function Se(t2) {
  return new ke(ye(8), (t3) => Le.fromBuffer(t3), (t3) => t3.toBuffer(), t2);
}
function Ee(t2) {
  return new ke(ye(32), (t3) => new PublicKey(t3), (t3) => t3.toBuffer(), t2);
}
function Ie(t2, e) {
  return new Me(t2, e);
}
var ke = class extends Gt {
  constructor(t2, e, n, r) {
    super(t2.span, r), this.layout = t2, this.decoder = e, this.encoder = n;
  }
  decode(t2, e) {
    return this.decoder(this.layout.decode(t2, e));
  }
  encode(t2, e, n) {
    return this.layout.encode(this.encoder(t2), e, n);
  }
  getSpan(t2, e) {
    return this.layout.getSpan(t2, e);
  }
};
var Me = class extends Gt {
  constructor(t2, e) {
    super(-1, e), this.layout = t2, this.discriminator = le();
  }
  encode(t2, e, n = 0) {
    return null == t2 ? this.layout.span + this.discriminator.encode(0, e, n) : (this.discriminator.encode(1, e, n), this.layout.encode(t2, e, n + 4) + 4);
  }
  decode(t2, e = 0) {
    const n = this.discriminator.decode(t2, e);
    if (0 === n)
      return null;
    if (1 === n)
      return this.layout.decode(t2, e + 4);
    throw new Error("Invalid coption " + this.layout.property);
  }
  getSpan(t2, e = 0) {
    return this.layout.getSpan(t2, e + 4) + 4;
  }
};
function xe(t2) {
  if (0 === t2)
    return false;
  if (1 === t2)
    return true;
  throw new Error("Invalid bool: " + t2);
}
function Pe(t2) {
  return t2 ? 1 : 0;
}
var Le = class extends import_bn.default {
  toBuffer() {
    const t2 = super.toArray().reverse(), e = Buffer.from(t2);
    if (8 === e.length)
      return e;
    if (e.length >= 8)
      throw new Error("u64 too large");
    const n = Buffer.alloc(8);
    return e.copy(n), n;
  }
  static fromBuffer(t2) {
    if (8 !== t2.length)
      throw new Error(`Invalid buffer length: ${t2.length}`);
    return new Le([...t2].reverse().map((t3) => `00${t3.toString(16)}`.slice(-2)).join(""), 16);
  }
};
var Te = class {
  constructor(t2) {
    this.idl = t2;
  }
  async encode(t2, e) {
    switch (t2) {
      case "token": {
        const t3 = Buffer.alloc(165), n = Be.encode(e, t3);
        return t3.slice(0, n);
      }
      case "mint": {
        const t3 = Buffer.alloc(82), n = Ce.encode(e, t3);
        return t3.slice(0, n);
      }
      default:
        throw new Error(`Invalid account name: ${t2}`);
    }
  }
  decode(t2, e) {
    return this.decodeUnchecked(t2, e);
  }
  decodeUnchecked(t2, e) {
    switch (t2) {
      case "token":
        return function(t3) {
          return Be.decode(t3);
        }(e);
      case "mint":
        return function(t3) {
          return Ce.decode(t3);
        }(e);
      default:
        throw new Error(`Invalid account name: ${t2}`);
    }
  }
  memcmp(t2, e) {
    switch (t2) {
      case "token":
        return { dataSize: 165 };
      case "mint":
        return { dataSize: 82 };
      default:
        throw new Error(`Invalid account name: ${t2}`);
    }
  }
  size(t2) {
    var e;
    return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
  }
};
var Ce = fe([Ie(Ee(), "mintAuthority"), Se("supply"), de("decimals"), (ze = "isInitialized", new ke(de(), xe, Pe, ze)), Ie(Ee(), "freezeAuthority")]);
var ze;
var Be = fe([Ee("mint"), Ee("authority"), Se("amount"), Ie(Ee(), "delegate"), de("state"), Ie(Se(), "isNative"), Se("delegatedAmount"), Ie(Ee(), "closeAuthority")]);
var Oe = class {
  constructor(t2) {
  }
  decode(t2) {
    throw new Error("SPL token program does not have events");
  }
};
var De = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("SPL token does not have user-defined types");
  }
  decode(t2, e) {
    throw new Error("SPL token does not have user-defined types");
  }
};
var Ne = class {
  constructor(t2) {
    this.instruction = new ge(t2), this.accounts = new Te(t2), this.events = new Oe(t2), this.state = new _e(t2), this.types = new De(t2);
  }
};
var Re = class {
  constructor(t2) {
  }
  encode(t2, e) {
    switch ((0, import_camelcase.default)(t2)) {
      case "createAccount":
        return function({ lamports: t3, space: e2, owner: n }) {
          return Ke({ createAccount: { lamports: t3, space: e2, owner: n.toBuffer() } });
        }(e);
      case "assign":
        return function({ owner: t3 }) {
          return Ke({ assign: { owner: t3.toBuffer() } });
        }(e);
      case "transfer":
        return function({ lamports: t3 }) {
          return Ke({ transfer: { lamports: t3 } });
        }(e);
      case "createAccountWithSeed":
        return function({ base: t3, seed: e2, lamports: n, space: r, owner: o }) {
          return Ke({ createAccountWithSeed: { base: t3.toBuffer(), seed: e2, lamports: n, space: r, owner: o.toBuffer() } }, $e.getVariant(3).span + e2.length);
        }(e);
      case "advanceNonceAccount":
        return function({ authorized: t3 }) {
          return Ke({ advanceNonceAccount: { authorized: t3.toBuffer() } });
        }(e);
      case "withdrawNonceAccount":
        return function({ lamports: t3 }) {
          return Ke({ withdrawNonceAccount: { lamports: t3 } });
        }(e);
      case "initializeNonceAccount":
        return function({ authorized: t3 }) {
          return Ke({ initializeNonceAccount: { authorized: t3.toBuffer() } });
        }(e);
      case "authorizeNonceAccount":
        return function({ authorized: t3 }) {
          return Ke({ authorizeNonceAccount: { authorized: t3.toBuffer() } });
        }(e);
      case "allocate":
        return function({ space: t3 }) {
          return Ke({ allocate: { space: t3 } });
        }(e);
      case "allocateWithSeed":
        return function({ base: t3, seed: e2, space: n, owner: r }) {
          return Ke({ allocateWithSeed: { base: t3.toBuffer(), seed: e2, space: n, owner: r.toBuffer() } }, $e.getVariant(9).span + e2.length);
        }(e);
      case "assignWithSeed":
        return function({ base: t3, seed: e2, owner: n }) {
          return Ke({ assignWithSeed: { base: t3.toBuffer(), seed: e2, owner: n.toBuffer() } }, $e.getVariant(10).span + e2.length);
        }(e);
      case "transferWithSeed":
        return function({ lamports: t3, seed: e2, owner: n }) {
          return Ke({ transferWithSeed: { lamports: t3, seed: e2, owner: n.toBuffer() } }, $e.getVariant(11).span + e2.length);
        }(e);
      default:
        throw new Error(`Invalid instruction: ${t2}`);
    }
  }
  encodeState(t2, e) {
    throw new Error("System does not have state");
  }
};
var Ve = class extends Gt {
  constructor(t2) {
    super(-1, t2), this.property = t2, this.layout = fe([le("length"), le("lengthPadding"), ye(ue(le(), -8), "chars")], this.property);
  }
  encode(t2, e, n = 0) {
    if (null == t2)
      return this.layout.span;
    const r = { chars: Buffer.from(t2, "utf8") };
    return this.layout.encode(r, e, n);
  }
  decode(t2, e = 0) {
    return this.layout.decode(t2, e).chars.toString();
  }
  getSpan(t2, e = 0) {
    return le().span + le().span + new import_bn.default(new Uint8Array(t2).slice(e, e + 4), 10, "le").toNumber();
  }
};
function Ue(t2) {
  return new Ve(t2);
}
function je(t2) {
  return ye(32, t2);
}
var $e = me(le("instruction"));
function Ke(t2, e) {
  const n = Buffer.alloc(null != e ? e : qe), r = $e.encode(t2, n);
  return void 0 === e ? n.slice(0, r) : n;
}
$e.addVariant(0, fe([pe("lamports"), pe("space"), je("owner")]), "createAccount"), $e.addVariant(1, fe([je("owner")]), "assign"), $e.addVariant(2, fe([pe("lamports")]), "transfer"), $e.addVariant(3, fe([je("base"), Ue("seed"), pe("lamports"), pe("space"), je("owner")]), "createAccountWithSeed"), $e.addVariant(4, fe([je("authorized")]), "advanceNonceAccount"), $e.addVariant(5, fe([pe("lamports")]), "withdrawNonceAccount"), $e.addVariant(6, fe([je("authorized")]), "initializeNonceAccount"), $e.addVariant(7, fe([je("authorized")]), "authorizeNonceAccount"), $e.addVariant(8, fe([pe("space")]), "allocate"), $e.addVariant(9, fe([je("base"), Ue("seed"), pe("space"), je("owner")]), "allocateWithSeed"), $e.addVariant(10, fe([je("base"), Ue("seed"), je("owner")]), "assignWithSeed"), $e.addVariant(11, fe([pe("lamports"), Ue("seed"), je("owner")]), "transferWithSeed");
var qe = Math.max(...Object.values($e.registry).map((t2) => t2.span));
var Fe = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("System does not have state");
  }
  decode(t2) {
    throw new Error("System does not have state");
  }
};
var We = class {
  constructor(t2) {
    this.idl = t2;
  }
  async encode(t2, e) {
    if ("nonce" === t2) {
      const t3 = Buffer.alloc(NONCE_ACCOUNT_LENGTH), n = Je.encode(e, t3);
      return t3.slice(0, n);
    }
    throw new Error(`Invalid account name: ${t2}`);
  }
  decode(t2, e) {
    return this.decodeUnchecked(t2, e);
  }
  decodeUnchecked(t2, e) {
    if ("nonce" === t2)
      return function(t3) {
        return Je.decode(t3);
      }(e);
    throw new Error(`Invalid account name: ${t2}`);
  }
  memcmp(t2, e) {
    if ("nonce" === t2)
      return { dataSize: NONCE_ACCOUNT_LENGTH };
    throw new Error(`Invalid account name: ${t2}`);
  }
  size(t2) {
    var e;
    return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
  }
};
var Ge = class extends Gt {
  constructor(t2, e, n, r) {
    super(t2.span, r), this.layout = t2, this.decoder = e, this.encoder = n;
  }
  decode(t2, e) {
    return this.decoder(this.layout.decode(t2, e));
  }
  encode(t2, e, n) {
    return this.layout.encode(this.encoder(t2), e, n);
  }
  getSpan(t2, e) {
    return this.layout.getSpan(t2, e);
  }
};
function He(t2) {
  return new Ge(ye(32), (t3) => new PublicKey(t3), (t3) => t3.toBuffer(), t2);
}
var Je = fe([le("version"), le("state"), He("authorizedPubkey"), He("nonce"), fe([he("lamportsPerSignature")], "feeCalculator")]);
var Ze = class {
  constructor(t2) {
  }
  decode(t2) {
    throw new Error("System program does not have events");
  }
};
var Xe = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("System does not have user-defined types");
  }
  decode(t2, e) {
    throw new Error("System does not have user-defined types");
  }
};
var Qe = class {
  constructor(t2) {
    this.instruction = new Re(t2), this.accounts = new We(t2), this.events = new Ze(t2), this.state = new Fe(t2), this.types = new Xe(t2);
  }
};
var Ye = Object.freeze({ __proto__: null, hash: function(t2) {
  return (0, import_js_sha256.sha256)(t2);
} });
function tn(n, r, o) {
  const i = import_buffer.Buffer.concat([n.toBuffer(), import_buffer.Buffer.from(r), o.toBuffer()]), s = import_js_sha256.sha256.digest(i);
  return new PublicKey(import_buffer.Buffer.from(s));
}
function en(n, r) {
  let o = import_buffer.Buffer.alloc(0);
  n.forEach(function(e) {
    if (e.length > 32)
      throw new TypeError("Max seed length exceeded");
    o = import_buffer.Buffer.concat([o, rn(e)]);
  }), o = import_buffer.Buffer.concat([o, r.toBuffer(), import_buffer.Buffer.from("ProgramDerivedAddress")]);
  let i = (0, import_js_sha256.sha256)(new Uint8Array(o)), s = new import_bn.default(i, 16).toArray(void 0, 32);
  if (PublicKey.isOnCurve(new Uint8Array(s)))
    throw new Error("Invalid seeds, address must fall off the curve");
  return new PublicKey(s);
}
function nn(e, n) {
  let r, o = 255;
  for (; 0 != o; ) {
    try {
      r = en(e.concat(import_buffer.Buffer.from([o])), n);
    } catch (t2) {
      if (t2 instanceof TypeError)
        throw t2;
      o--;
      continue;
    }
    return [r, o];
  }
  throw new Error("Unable to find a viable program address nonce");
}
var rn = (e) => e instanceof import_buffer.Buffer ? e : e instanceof Uint8Array ? import_buffer.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : import_buffer.Buffer.from(e);
async function on(n, ...r) {
  let o = [import_buffer.Buffer.from([97, 110, 99, 104, 111, 114])];
  r.forEach((e) => {
    o.push(e instanceof import_buffer.Buffer ? e : L(e).toBuffer());
  });
  const [i] = await PublicKey.findProgramAddress(o, L(n));
  return i;
}
var sn = Object.freeze({ __proto__: null, createWithSeedSync: tn, createProgramAddressSync: en, findProgramAddressSync: nn, associated: on });
var an = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var cn = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var un = Object.freeze({ __proto__: null, TOKEN_PROGRAM_ID: an, ASSOCIATED_PROGRAM_ID: cn, associatedAddress: async function({ mint: t2, owner: n }) {
  return (await PublicKey.findProgramAddress([n.toBuffer(), an.toBuffer(), t2.toBuffer()], cn))[0];
} });
var dn = { exports: {} };
!function(t2, e) {
  var n = "undefined" != typeof self ? self : qt, r = function() {
    function t3() {
      this.fetch = false, this.DOMException = n.DOMException;
    }
    return t3.prototype = n, new t3();
  }();
  !function(t3) {
    !function(e2) {
      var n2 = "URLSearchParams" in t3, r2 = "Symbol" in t3 && "iterator" in Symbol, o2 = "FileReader" in t3 && "Blob" in t3 && function() {
        try {
          return new Blob(), true;
        } catch (t4) {
          return false;
        }
      }(), i = "FormData" in t3, s = "ArrayBuffer" in t3;
      if (s)
        var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], c = ArrayBuffer.isView || function(t4) {
          return t4 && a.indexOf(Object.prototype.toString.call(t4)) > -1;
        };
      function u2(t4) {
        if ("string" != typeof t4 && (t4 = String(t4)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(t4))
          throw new TypeError("Invalid character in header field name");
        return t4.toLowerCase();
      }
      function d2(t4) {
        return "string" != typeof t4 && (t4 = String(t4)), t4;
      }
      function l2(t4) {
        var e3 = { next: function() {
          var e4 = t4.shift();
          return { done: void 0 === e4, value: e4 };
        } };
        return r2 && (e3[Symbol.iterator] = function() {
          return e3;
        }), e3;
      }
      function h2(t4) {
        this.map = {}, t4 instanceof h2 ? t4.forEach(function(t5, e3) {
          this.append(e3, t5);
        }, this) : Array.isArray(t4) ? t4.forEach(function(t5) {
          this.append(t5[0], t5[1]);
        }, this) : t4 && Object.getOwnPropertyNames(t4).forEach(function(e3) {
          this.append(e3, t4[e3]);
        }, this);
      }
      function p2(t4) {
        if (t4.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        t4.bodyUsed = true;
      }
      function f2(t4) {
        return new Promise(function(e3, n3) {
          t4.onload = function() {
            e3(t4.result);
          }, t4.onerror = function() {
            n3(t4.error);
          };
        });
      }
      function m(t4) {
        var e3 = new FileReader(), n3 = f2(e3);
        return e3.readAsArrayBuffer(t4), n3;
      }
      function y2(t4) {
        if (t4.slice)
          return t4.slice(0);
        var e3 = new Uint8Array(t4.byteLength);
        return e3.set(new Uint8Array(t4)), e3.buffer;
      }
      function g2() {
        return this.bodyUsed = false, this._initBody = function(t4) {
          var e3;
          this._bodyInit = t4, t4 ? "string" == typeof t4 ? this._bodyText = t4 : o2 && Blob.prototype.isPrototypeOf(t4) ? this._bodyBlob = t4 : i && FormData.prototype.isPrototypeOf(t4) ? this._bodyFormData = t4 : n2 && URLSearchParams.prototype.isPrototypeOf(t4) ? this._bodyText = t4.toString() : s && o2 && ((e3 = t4) && DataView.prototype.isPrototypeOf(e3)) ? (this._bodyArrayBuffer = y2(t4.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(t4) || c(t4)) ? this._bodyArrayBuffer = y2(t4) : this._bodyText = t4 = Object.prototype.toString.call(t4) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof t4 ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : n2 && URLSearchParams.prototype.isPrototypeOf(t4) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, o2 && (this.blob = function() {
          var t4 = p2(this);
          if (t4)
            return t4;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? p2(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(m);
        }), this.text = function() {
          var t4 = p2(this);
          if (t4)
            return t4;
          if (this._bodyBlob)
            return function(t5) {
              var e3 = new FileReader(), n3 = f2(e3);
              return e3.readAsText(t5), n3;
            }(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(function(t5) {
              for (var e3 = new Uint8Array(t5), n3 = new Array(e3.length), r3 = 0; r3 < e3.length; r3++)
                n3[r3] = String.fromCharCode(e3[r3]);
              return n3.join("");
            }(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, i && (this.formData = function() {
          return this.text().then(b2);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      h2.prototype.append = function(t4, e3) {
        t4 = u2(t4), e3 = d2(e3);
        var n3 = this.map[t4];
        this.map[t4] = n3 ? n3 + ", " + e3 : e3;
      }, h2.prototype.delete = function(t4) {
        delete this.map[u2(t4)];
      }, h2.prototype.get = function(t4) {
        return t4 = u2(t4), this.has(t4) ? this.map[t4] : null;
      }, h2.prototype.has = function(t4) {
        return this.map.hasOwnProperty(u2(t4));
      }, h2.prototype.set = function(t4, e3) {
        this.map[u2(t4)] = d2(e3);
      }, h2.prototype.forEach = function(t4, e3) {
        for (var n3 in this.map)
          this.map.hasOwnProperty(n3) && t4.call(e3, this.map[n3], n3, this);
      }, h2.prototype.keys = function() {
        var t4 = [];
        return this.forEach(function(e3, n3) {
          t4.push(n3);
        }), l2(t4);
      }, h2.prototype.values = function() {
        var t4 = [];
        return this.forEach(function(e3) {
          t4.push(e3);
        }), l2(t4);
      }, h2.prototype.entries = function() {
        var t4 = [];
        return this.forEach(function(e3, n3) {
          t4.push([n3, e3]);
        }), l2(t4);
      }, r2 && (h2.prototype[Symbol.iterator] = h2.prototype.entries);
      var w2 = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function v2(t4, e3) {
        var n3, r3, o3 = (e3 = e3 || {}).body;
        if (t4 instanceof v2) {
          if (t4.bodyUsed)
            throw new TypeError("Already read");
          this.url = t4.url, this.credentials = t4.credentials, e3.headers || (this.headers = new h2(t4.headers)), this.method = t4.method, this.mode = t4.mode, this.signal = t4.signal, o3 || null == t4._bodyInit || (o3 = t4._bodyInit, t4.bodyUsed = true);
        } else
          this.url = String(t4);
        if (this.credentials = e3.credentials || this.credentials || "same-origin", !e3.headers && this.headers || (this.headers = new h2(e3.headers)), this.method = (n3 = e3.method || this.method || "GET", r3 = n3.toUpperCase(), w2.indexOf(r3) > -1 ? r3 : n3), this.mode = e3.mode || this.mode || null, this.signal = e3.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && o3)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(o3);
      }
      function b2(t4) {
        var e3 = new FormData();
        return t4.trim().split("&").forEach(function(t5) {
          if (t5) {
            var n3 = t5.split("="), r3 = n3.shift().replace(/\+/g, " "), o3 = n3.join("=").replace(/\+/g, " ");
            e3.append(decodeURIComponent(r3), decodeURIComponent(o3));
          }
        }), e3;
      }
      function A2(t4, e3) {
        e3 || (e3 = {}), this.type = "default", this.status = void 0 === e3.status ? 200 : e3.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in e3 ? e3.statusText : "OK", this.headers = new h2(e3.headers), this.url = e3.url || "", this._initBody(t4);
      }
      v2.prototype.clone = function() {
        return new v2(this, { body: this._bodyInit });
      }, g2.call(v2.prototype), g2.call(A2.prototype), A2.prototype.clone = function() {
        return new A2(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new h2(this.headers), url: this.url });
      }, A2.error = function() {
        var t4 = new A2(null, { status: 0, statusText: "" });
        return t4.type = "error", t4;
      };
      var _2 = [301, 302, 303, 307, 308];
      A2.redirect = function(t4, e3) {
        if (-1 === _2.indexOf(e3))
          throw new RangeError("Invalid status code");
        return new A2(null, { status: e3, headers: { location: t4 } });
      }, e2.DOMException = t3.DOMException;
      try {
        new e2.DOMException();
      } catch (t4) {
        e2.DOMException = function(t5, e3) {
          this.message = t5, this.name = e3;
          var n3 = Error(t5);
          this.stack = n3.stack;
        }, e2.DOMException.prototype = Object.create(Error.prototype), e2.DOMException.prototype.constructor = e2.DOMException;
      }
      function S2(t4, n3) {
        return new Promise(function(r3, i2) {
          var s2 = new v2(t4, n3);
          if (s2.signal && s2.signal.aborted)
            return i2(new e2.DOMException("Aborted", "AbortError"));
          var a2 = new XMLHttpRequest();
          function c2() {
            a2.abort();
          }
          a2.onload = function() {
            var t5, e3, n4 = { status: a2.status, statusText: a2.statusText, headers: (t5 = a2.getAllResponseHeaders() || "", e3 = new h2(), t5.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach(function(t6) {
              var n5 = t6.split(":"), r4 = n5.shift().trim();
              if (r4) {
                var o4 = n5.join(":").trim();
                e3.append(r4, o4);
              }
            }), e3) };
            n4.url = "responseURL" in a2 ? a2.responseURL : n4.headers.get("X-Request-URL");
            var o3 = "response" in a2 ? a2.response : a2.responseText;
            r3(new A2(o3, n4));
          }, a2.onerror = function() {
            i2(new TypeError("Network request failed"));
          }, a2.ontimeout = function() {
            i2(new TypeError("Network request failed"));
          }, a2.onabort = function() {
            i2(new e2.DOMException("Aborted", "AbortError"));
          }, a2.open(s2.method, s2.url, true), "include" === s2.credentials ? a2.withCredentials = true : "omit" === s2.credentials && (a2.withCredentials = false), "responseType" in a2 && o2 && (a2.responseType = "blob"), s2.headers.forEach(function(t5, e3) {
            a2.setRequestHeader(e3, t5);
          }), s2.signal && (s2.signal.addEventListener("abort", c2), a2.onreadystatechange = function() {
            4 === a2.readyState && s2.signal.removeEventListener("abort", c2);
          }), a2.send(void 0 === s2._bodyInit ? null : s2._bodyInit);
        });
      }
      S2.polyfill = true, t3.fetch || (t3.fetch = S2, t3.Headers = h2, t3.Request = v2, t3.Response = A2), e2.Headers = h2, e2.Request = v2, e2.Response = A2, e2.fetch = S2, Object.defineProperty(e2, "__esModule", { value: true });
    }({});
  }(r), r.fetch.ponyfill = true, delete r.fetch.polyfill;
  var o = r;
  (e = o.fetch).default = o.fetch, e.fetch = o.fetch, e.Headers = o.Headers, e.Request = o.Request, e.Response = o.Response, t2.exports = e;
}(dn, dn.exports);
var ln = Ft(dn.exports);
async function hn(t2, e) {
  const n = await t2.getAccountInfo(e);
  if (null === n)
    throw new Error("program account not found");
  const { program: r } = fn(n.data), o = await t2.getAccountInfo(r.programdataAddress);
  if (null === o)
    throw new Error("program data account not found");
  const { programData: i } = fn(o.data);
  return i;
}
var pn = f.rustEnum([f.struct([], "uninitialized"), f.struct([f.option(f.publicKey(), "authorityAddress")], "buffer"), f.struct([f.publicKey("programdataAddress")], "program"), f.struct([f.u64("slot"), f.option(f.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, f.u32());
function fn(t2) {
  return pn.decode(t2);
}
var mn = Object.freeze({ __proto__: null, verifiedBuild: async function(t2, e, n = 5) {
  const r = `https://api.apr.dev/api/v0/program/${e.toString()}/latest?limit=${n}`, [o, i] = await Promise.all([hn(t2, e), ln(r)]), s = (await i.json()).filter((t3) => !t3.aborted && "Built" === t3.state && "Verified" === t3.verified);
  if (0 === s.length)
    return null;
  const a = s[0];
  return o.slot.toNumber() !== a.verified_slot ? null : a;
}, fetchData: hn, decodeUpgradeableLoaderState: fn });
var yn = Object.freeze({ __proto__: null, sha256: Ye, rpc: it, publicKey: sn, bytes: k, token: un, features: yt, registry: mn });
var gn = f.struct([f.publicKey("authority"), f.vecU8("data")]);
function wn(t2, e) {
  var n, r;
  let o = {};
  const i = t2.args ? t2.args.length : 0;
  if (e.length > i) {
    if (e.length !== i + 1)
      throw new Error(`provided too many arguments ${e} to instruction ${null == t2 ? void 0 : t2.name} expecting: ${null !== (r = null === (n = t2.args) || void 0 === n ? void 0 : n.map((t3) => t3.name)) && void 0 !== r ? r : []}`);
    o = e.pop();
  }
  return [e, o];
}
var vn = class {
  static build(t2, e, n) {
    if ("_inner" === t2.name)
      throw new gt("the _inner name is reserved");
    const o = (...i) => {
      const [s, a] = wn(t2, [...i]);
      P(t2.accounts, a.accounts);
      const c = o.accounts(a.accounts);
      return void 0 !== a.remainingAccounts && c.push(...a.remainingAccounts), mt("debug-logs") && console.log("Outgoing account metas:", c), new TransactionInstruction({ keys: c, programId: n, data: e(t2.name, x(t2, ...s)) });
    };
    return o.accounts = (e2) => vn.accountsArray(e2, t2.accounts, t2.name), o;
  }
  static accountsArray(t2, e, n) {
    return t2 ? e.map((e2) => {
      if (void 0 !== ("accounts" in e2 ? e2.accounts : void 0)) {
        const r = t2[e2.name];
        return vn.accountsArray(r, e2.accounts, n).flat();
      }
      {
        const r = e2;
        let o;
        try {
          o = L(t2[e2.name]);
        } catch (t3) {
          throw new Error(`Wrong input type for account "${e2.name}" in the instruction accounts object${void 0 !== n ? ' for instruction "' + n + '"' : ""}. Expected PublicKey or string.`);
        }
        return { pubkey: o, isWritable: r.isMut, isSigner: r.isSigner };
      }
    }).flat() : [];
  }
};
var bn = class {
  static build(t2, e, n, r) {
    return async (...o) => {
      var i;
      const s = e(...o), [, a] = wn(t2, [...o]);
      if (void 0 === r.sendAndConfirm)
        throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
      try {
        return await r.sendAndConfirm(s, null !== (i = a.signers) && void 0 !== i ? i : [], a.options);
      } catch (t3) {
        throw At(t3, n);
      }
    };
  }
};
var An = class {
  static build(t2, e) {
    return (...r) => {
      var o, i, s;
      const [, a] = wn(t2, [...r]), c = new Transaction();
      if (a.preInstructions && a.instructions)
        throw new Error("instructions is deprecated, use preInstructions");
      return null === (o = a.preInstructions) || void 0 === o || o.forEach((t3) => c.add(t3)), null === (i = a.instructions) || void 0 === i || i.forEach((t3) => c.add(t3)), c.add(e(...r)), null === (s = a.postInstructions) || void 0 === s || s.forEach((t3) => c.add(t3)), c;
    };
  }
};
var _n = class {
  constructor(t2, e, n = lt(), r = new Kt(t2)) {
    this.provider = n, this.coder = r, this._idl = t2, this._programId = e, this._address = Sn(e), this._sub = null;
    const [o, i, a] = (() => {
      var o2;
      let i2 = {}, a2 = {}, c = {};
      return null === (o2 = t2.state) || void 0 === o2 || o2.methods.forEach((o3) => {
        const u2 = vn.build(o3, (t3, e2) => r.instruction.encodeState(t3, e2), e);
        u2.accounts = (t3) => {
          const r2 = function(t4, e2, n2, r3) {
            if ("new" === n2.name) {
              const [n3] = nn([], t4);
              if (void 0 === e2.wallet)
                throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
              return [{ pubkey: e2.wallet.publicKey, isWritable: false, isSigner: true }, { pubkey: Sn(t4), isWritable: true, isSigner: false }, { pubkey: n3, isWritable: false, isSigner: false }, { pubkey: SystemProgram.programId, isWritable: false, isSigner: false }, { pubkey: t4, isWritable: false, isSigner: false }];
            }
            return P(n2.accounts, r3), [{ pubkey: Sn(t4), isWritable: true, isSigner: false }];
          }(e, n, o3, t3);
          return r2.concat(vn.accountsArray(t3, o3.accounts, o3.name));
        };
        const d2 = An.build(o3, u2), l2 = bn.build(o3, d2, M(t2), n), p2 = (0, import_camelcase.default)(o3.name);
        i2[p2] = u2, a2[p2] = d2, c[p2] = l2;
      }), [i2, a2, c];
    })();
    this.instruction = o, this.transaction = i, this.rpc = a;
  }
  get programId() {
    return this._programId;
  }
  async fetch() {
    const t2 = this.address(), e = await this.provider.connection.getAccountInfo(t2);
    if (null === e)
      throw new Error(`Account does not exist ${t2.toString()}`);
    const n = this._idl.state;
    if (!n)
      throw new Error("State is not specified in IDL.");
    if ((await jt(n.struct.name)).compare(e.data.slice(0, 8)))
      throw new Error("Invalid account discriminator");
    return this.coder.state.decode(e.data);
  }
  address() {
    return this._address;
  }
  subscribe(t2) {
    if (null !== this._sub)
      return this._sub.ee;
    const e = new import_eventemitter3.default(), n = this.provider.connection.onAccountChange(this.address(), (t3) => {
      const n2 = this.coder.state.decode(t3.data);
      e.emit("change", n2);
    }, t2);
    return this._sub = { ee: e, listener: n }, e;
  }
  unsubscribe() {
    null !== this._sub && this.provider.connection.removeAccountChangeListener(this._sub.listener).then(async () => {
      this._sub = null;
    }).catch(console.error);
  }
};
function Sn(t2) {
  let [e] = nn([], t2);
  return tn(e, "unversioned", t2);
}
var En = class {
  constructor(t2, e, n, r, o) {
    this._idlAccount = e, this._programId = n, this._provider = null != r ? r : lt(), this._coder = null != o ? o : new Kt(t2), this._size = this._coder.accounts.size(e);
  }
  get size() {
    return this._size;
  }
  get programId() {
    return this._programId;
  }
  get provider() {
    return this._provider;
  }
  get coder() {
    return this._coder;
  }
  async fetchNullable(t2, e) {
    const n = await this.getAccountInfo(t2, e);
    return null === n ? null : this._coder.accounts.decode(this._idlAccount.name, n.data);
  }
  async fetch(t2, e) {
    const n = await this.fetchNullable(t2, e);
    if (null === n)
      throw new Error(`Account does not exist ${t2.toString()}`);
    return n;
  }
  async fetchMultiple(t2, e) {
    return (await X(this._provider.connection, t2.map((t3) => L(t3)), e)).map((t3) => null == t3 ? null : this._coder.accounts.decode(this._idlAccount.name, null == t3 ? void 0 : t3.account.data));
  }
  async all(t2) {
    return (await this._provider.connection.getProgramAccounts(this._programId, { commitment: this._provider.connection.commitment, filters: [{ memcmp: this.coder.accounts.memcmp(this._idlAccount.name, t2 instanceof Buffer ? t2 : void 0) }, ...Array.isArray(t2) ? t2 : []] })).map(({ pubkey: t3, account: e }) => ({ publicKey: t3, account: this._coder.accounts.decode(this._idlAccount.name, e.data) }));
  }
  subscribe(t2, e) {
    const n = In.get(t2.toString());
    if (n)
      return n.ee;
    const r = new import_eventemitter3.default();
    t2 = L(t2);
    const o = this._provider.connection.onAccountChange(t2, (t3) => {
      const e2 = this._coder.accounts.decode(this._idlAccount.name, t3.data);
      r.emit("change", e2);
    }, e);
    return In.set(t2.toString(), { ee: r, listener: o }), r;
  }
  async unsubscribe(t2) {
    let e = In.get(t2.toString());
    e ? In && await this._provider.connection.removeAccountChangeListener(e.listener).then(() => {
      In.delete(t2.toString());
    }).catch(console.error) : console.warn("Address is not subscribed");
  }
  async createInstruction(t2, e) {
    const n = this.size;
    if (void 0 === this._provider.wallet)
      throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
    return SystemProgram.createAccount({ fromPubkey: this._provider.wallet.publicKey, newAccountPubkey: t2.publicKey, space: null != e ? e : n, lamports: await this._provider.connection.getMinimumBalanceForRentExemption(null != e ? e : n), programId: this._programId });
  }
  async associated(...t2) {
    const e = await this.associatedAddress(...t2);
    return await this.fetch(e);
  }
  async associatedAddress(...t2) {
    return await on(this._programId, ...t2);
  }
  async getAccountInfo(t2, e) {
    return await this._provider.connection.getAccountInfo(L(t2), e);
  }
};
var In = /* @__PURE__ */ new Map();
var kn = "Program log: ".length;
var Mn = "Program data: ".length;
var xn = class {
  constructor(t2, e, n) {
    this._programId = t2, this._provider = e, this._eventParser = new Pn(t2, n), this._eventCallbacks = /* @__PURE__ */ new Map(), this._eventListeners = /* @__PURE__ */ new Map(), this._listenerIdCount = 0;
  }
  addEventListener(t2, e) {
    var n;
    let r = this._listenerIdCount;
    return this._listenerIdCount += 1, t2 in this._eventCallbacks || this._eventListeners.set(t2, []), this._eventListeners.set(t2, (null !== (n = this._eventListeners.get(t2)) && void 0 !== n ? n : []).concat(r)), this._eventCallbacks.set(r, [t2, e]), void 0 !== this._onLogsSubscriptionId || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (t3, e2) => {
      if (!t3.err)
        for (const n2 of this._eventParser.parseLogs(t3.logs)) {
          const r2 = this._eventListeners.get(n2.name);
          r2 && r2.forEach((r3) => {
            const o = this._eventCallbacks.get(r3);
            if (o) {
              const [, r4] = o;
              r4(n2.data, e2.slot, t3.signature);
            }
          });
        }
    })), r;
  }
  async removeEventListener(t2) {
    const e = this._eventCallbacks.get(t2);
    if (!e)
      throw new Error(`Event listener ${t2} doesn't exist!`);
    const [n] = e;
    let r = this._eventListeners.get(n);
    if (!r)
      throw new Error(`Event listeners don't exist for ${n}!`);
    this._eventCallbacks.delete(t2), r = r.filter((e2) => e2 !== t2), 0 === r.length && this._eventListeners.delete(n), 0 == this._eventCallbacks.size && (g.ok(0 === this._eventListeners.size), void 0 !== this._onLogsSubscriptionId && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0));
  }
};
var Pn = class {
  constructor(t2, e) {
    this.coder = e, this.programId = t2;
  }
  *parseLogs(t2) {
    const e = new Tn(t2), n = new Ln();
    let r = e.next();
    for (; null !== r; ) {
      let [t3, o, i] = this.handleLog(n, r);
      t3 && (yield t3), o && n.push(o), i && n.pop(), r = e.next();
    }
  }
  handleLog(t2, e) {
    return t2.stack.length > 0 && t2.program() === this.programId.toString() ? this.handleProgramLog(e) : [null, ...this.handleSystemLog(e)];
  }
  handleProgramLog(t2) {
    if (t2.startsWith("Program log: ") || t2.startsWith("Program data: ")) {
      const e = t2.startsWith("Program log: ") ? t2.slice(kn) : t2.slice(Mn);
      return [this.coder.events.decode(e), null, false];
    }
    return [null, ...this.handleSystemLog(t2)];
  }
  handleSystemLog(t2) {
    const e = t2.split(":")[0];
    return null !== e.match(/^Program (.*) success/g) ? [null, true] : e.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), false] : e.includes("invoke") ? ["cpi", false] : [null, false];
  }
};
var Ln = class {
  constructor() {
    this.stack = [];
  }
  program() {
    return g.ok(this.stack.length > 0), this.stack[this.stack.length - 1];
  }
  push(t2) {
    this.stack.push(t2);
  }
  pop() {
    g.ok(this.stack.length > 0), this.stack.pop();
  }
};
var Tn = class {
  constructor(t2) {
    this.logs = t2;
  }
  next() {
    if (0 === this.logs.length)
      return null;
    let t2 = this.logs[0];
    return this.logs = this.logs.slice(1), t2;
  }
};
var Cn = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
function zn() {
  return new Ne(Bn);
}
var Bn = { version: "0.1.0", name: "spl_token", instructions: [{ name: "initializeMint", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "decimals", type: "u8" }, { name: "mintAuthority", type: "publicKey" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] }, { name: "initializeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [] }, { name: "initializeMultisig", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "m", type: "u8" }] }, { name: "transfer", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "approve", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "delegate", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "revoke", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "setAuthority", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "authorityType", type: "u8" }, { name: "newAuthority", type: { coption: "publicKey" } }] }, { name: "mintTo", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "burn", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }] }, { name: "closeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: false }], args: [] }, { name: "freezeAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "thawAccount", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [] }, { name: "transferChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "destination", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "approveChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "delegate", isMut: false, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "mintToChecked", accounts: [{ name: "mint", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "burnChecked", accounts: [{ name: "source", isMut: true, isSigner: false }, { name: "mint", isMut: true, isSigner: false }, { name: "authority", isMut: false, isSigner: true }], args: [{ name: "amount", type: "u64" }, { name: "decimals", type: "u8" }] }, { name: "initializeAccount2", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "authority", type: "publicKey" }] }, { name: "syncNative", accounts: [{ name: "account", isMut: true, isSigner: false }], args: [] }, { name: "initializeAccount3", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "mint", isMut: false, isSigner: false }], args: [{ name: "authority", type: "publicKey" }] }, { name: "initializeMultisig2", accounts: [{ name: "account", isMut: true, isSigner: false }], args: [{ name: "m", type: "u8" }] }, { name: "initializeMint2", accounts: [{ name: "mint", isMut: true, isSigner: false }], args: [{ name: "decimals", type: "u8" }, { name: "mintAuthority", type: "publicKey" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] }], accounts: [{ name: "mint", type: { kind: "struct", fields: [{ name: "mintAuthority", type: { coption: "publicKey" } }, { name: "supply", type: "u64" }, { name: "decimals", type: "u8" }, { name: "isInitialized", type: "bool" }, { name: "freezeAuthority", type: { coption: "publicKey" } }] } }, { name: "token", type: { kind: "struct", fields: [{ name: "mint", type: "publicKey" }, { name: "authority", type: "publicKey" }, { name: "amount", type: "u64" }, { name: "delegate", type: { coption: "publicKey" } }, { name: "state", type: "u8" }, { name: "isNative", type: { coption: "u64" } }, { name: "delegatedAmount", type: "u64" }, { name: "closeAuthority", type: { coption: "publicKey" } }] } }] };
var On = class {
  constructor(t2, e, n, r, o, i) {
    this._args = t2, this._accounts = e, this._provider = n, this._programId = r, this._idlIx = o, this._accountStore = new Dn(n, i);
  }
  async resolve() {
    for (let t2 = 0; t2 < this._idlIx.accounts.length; t2 += 1) {
      const e = this._idlIx.accounts[t2], n = (0, import_camelcase.default)(e.name);
      if (!e.isSigner || this._accounts[n])
        Reflect.has(On.CONST_ACCOUNTS, n) && !this._accounts[n] && (this._accounts[n] = On.CONST_ACCOUNTS[n]);
      else {
        if (void 0 === this._provider.wallet)
          throw new Error("This function requires the Provider interface implementor to have a 'wallet' field.");
        this._accounts[n] = this._provider.wallet.publicKey;
      }
    }
    for (let t2 = 0; t2 < this._idlIx.accounts.length; t2 += 1) {
      const e = this._idlIx.accounts[t2], n = (0, import_camelcase.default)(e.name);
      e.pda && e.pda.seeds.length > 0 && !this._accounts[n] && await this.autoPopulatePda(e);
    }
  }
  async autoPopulatePda(t2) {
    if (!t2.pda || !t2.pda.seeds)
      throw new Error("Must have seeds");
    const n = await Promise.all(t2.pda.seeds.map((t3) => this.toBuffer(t3))), r = await this.parseProgramId(t2), [o] = await PublicKey.findProgramAddress(n, r);
    this._accounts[(0, import_camelcase.default)(t2.name)] = o;
  }
  async parseProgramId(t2) {
    var n;
    if (!(null === (n = t2.pda) || void 0 === n ? void 0 : n.programId))
      return this._programId;
    switch (t2.pda.programId.kind) {
      case "const":
        return new PublicKey(this.toBufferConst(t2.pda.programId.value));
      case "arg":
        return this.argValue(t2.pda.programId);
      case "account":
        return await this.accountValue(t2.pda.programId);
      default:
        throw new Error(`Unexpected program seed kind: ${t2.pda.programId.kind}`);
    }
  }
  async toBuffer(t2) {
    switch (t2.kind) {
      case "const":
        return this.toBufferConst(t2);
      case "arg":
        return await this.toBufferArg(t2);
      case "account":
        return await this.toBufferAccount(t2);
      default:
        throw new Error(`Unexpected seed kind: ${t2.kind}`);
    }
  }
  toBufferConst(t2) {
    return this.toBufferValue(t2.type, t2.value);
  }
  async toBufferArg(t2) {
    const e = this.argValue(t2);
    return this.toBufferValue(t2.type, e);
  }
  argValue(t2) {
    const e = (0, import_camelcase.default)(t2.path.split(".")[0]), n = this._idlIx.args.findIndex((t3) => t3.name === e);
    if (-1 === n)
      throw new Error(`Unable to find argument for seed: ${e}`);
    return this._args[n];
  }
  async toBufferAccount(t2) {
    const e = await this.accountValue(t2);
    return this.toBufferValue(t2.type, e);
  }
  async accountValue(t2) {
    const e = t2.path.split("."), n = e[0], r = this._accounts[(0, import_camelcase.default)(n)];
    if (1 === e.length)
      return r;
    const o = await this._accountStore.fetchAccount(t2.account, r);
    return this.parseAccountValue(o, e.slice(1));
  }
  parseAccountValue(t2, e) {
    let n;
    for (; e.length > 0; )
      n = t2[(0, import_camelcase.default)(e[0])], e = e.slice(1);
    return n;
  }
  toBufferValue(t2, e) {
    switch (t2) {
      case "u8":
        return Buffer.from([e]);
      case "u16":
        let n = Buffer.alloc(2);
        return n.writeUInt16LE(e), n;
      case "u32":
        let r = Buffer.alloc(4);
        return r.writeUInt32LE(e), r;
      case "u64":
        let o = Buffer.alloc(8);
        return o.writeBigUInt64LE(BigInt(e)), o;
      case "string":
        return Buffer.from(b(e));
      case "publicKey":
        return e.toBuffer();
      default:
        if (t2.array)
          return Buffer.from(e);
        throw new Error(`Unexpected seed type: ${t2}`);
    }
  }
};
On.CONST_ACCOUNTS = { associatedTokenProgram: cn, rent: SYSVAR_RENT_PUBKEY, systemProgram: SystemProgram.programId, tokenProgram: an };
var Dn = class {
  constructor(t2, e) {
    this._provider = t2, this._accounts = e, this._cache = /* @__PURE__ */ new Map();
  }
  async fetchAccount(t2, e) {
    const n = e.toString();
    if (!this._cache.has(n))
      if ("TokenAccount" === t2) {
        const t3 = await this._provider.connection.getAccountInfo(e);
        if (null === t3)
          throw new Error(`invalid account info for ${n}`);
        const r = zn().accounts.decode("token", t3.data);
        this._cache.set(n, r);
      } else {
        const r = this._accounts[(0, import_camelcase.default)(t2)].fetch(e);
        this._cache.set(n, r);
      }
    return this._cache.get(n);
  }
};
var Nn = class {
  static build(t2, e, n, r, o, i, s, a, c) {
    return (...u2) => new Rn(u2, r, o, i, s, a, t2, e, n, c);
  }
};
var Rn = class {
  constructor(t2, e, n, r, o, i, s, a, c, u2) {
    this._args = t2, this._ixFn = e, this._txFn = n, this._rpcFn = r, this._simulateFn = o, this._viewFn = i, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._autoResolveAccounts = true, this._accountsResolver = new On(t2, this._accounts, s, a, c, u2);
  }
  async pubkeys() {
    return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._accounts;
  }
  accounts(t2) {
    return this._autoResolveAccounts = true, Object.assign(this._accounts, t2), this;
  }
  accountsStrict(t2) {
    return this._autoResolveAccounts = false, Object.assign(this._accounts, t2), this;
  }
  signers(t2) {
    return this._signers = this._signers.concat(t2), this;
  }
  remainingAccounts(t2) {
    return this._remainingAccounts = this._remainingAccounts.concat(t2), this;
  }
  preInstructions(t2) {
    return this._preInstructions = this._preInstructions.concat(t2), this;
  }
  postInstructions(t2) {
    return this._postInstructions = this._postInstructions.concat(t2), this;
  }
  async rpc(t2) {
    return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._rpcFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
  }
  async view(t2) {
    if (this._autoResolveAccounts && await this._accountsResolver.resolve(), !this._viewFn)
      throw new Error("Method does not support views");
    return this._viewFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
  }
  async simulate(t2) {
    return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._simulateFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions, options: t2 });
  }
  async instruction() {
    return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._ixFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions });
  }
  async transaction() {
    return this._autoResolveAccounts && await this._accountsResolver.resolve(), this._txFn(...this._args, { accounts: this._accounts, signers: this._signers, remainingAccounts: this._remainingAccounts, preInstructions: this._preInstructions, postInstructions: this._postInstructions });
  }
};
var Vn = class {
  constructor(t2, e, n, r) {
    e = L(e), n || (n = lt()), this._idl = t2, this._provider = n, this._programId = e, this._coder = null != r ? r : new Kt(t2), this._events = new xn(this._programId, n, this._coder);
    const [o, i, s, a, c, u2, d2, l2] = class {
      static build(t3, e2, n2, r2) {
        const o2 = {}, i2 = {}, s2 = {}, a2 = {}, c2 = {}, u3 = {}, d3 = M(t3), l3 = t3.accounts ? class {
          static build(t4, e3, n3, r3) {
            var o3;
            const i3 = {};
            return null === (o3 = t4.accounts) || void 0 === o3 || o3.forEach((o4) => {
              const s3 = (0, import_camelcase.default)(o4.name);
              i3[s3] = new En(t4, o4, n3, r3, e3);
            }), i3;
          }
        }.build(t3, e2, n2, r2) : {}, p2 = class {
          static build(t4, e3, n3, r3) {
            if (void 0 !== t4.state)
              return new _n(t4, n3, r3, e3);
          }
        }.build(t3, e2, n2, r2);
        return t3.instructions.forEach((p3) => {
          const f2 = vn.build(p3, (t4, n3) => e2.instruction.encode(t4, n3), n2), m = An.build(p3, f2), y2 = bn.build(p3, m, d3, r2), g2 = class {
            static build(t4, e3, n3, r3, o3, i3, s3) {
              return async (...a3) => {
                var c3;
                const u4 = e3(...a3), [, d4] = wn(t4, [...a3]);
                let l4;
                if (void 0 === r3.simulate)
                  throw new Error("This function requires 'Provider.simulate' to be implemented.");
                try {
                  l4 = await r3.simulate(u4, d4.signers, null === (c3 = d4.options) || void 0 === c3 ? void 0 : c3.commitment);
                } catch (t5) {
                  throw At(t5, n3);
                }
                if (void 0 === l4)
                  throw new Error("Unable to simulate transaction");
                const h2 = l4.logs;
                if (!h2)
                  throw new Error("Simulated logs not found");
                const p4 = [];
                if (s3.events) {
                  let t5 = new Pn(i3, o3);
                  for (const e4 of t5.parseLogs(h2))
                    p4.push(e4);
                }
                return { events: p4, raw: h2 };
              };
            }
          }.build(p3, m, d3, r2, e2, n2, t3), w2 = class {
            static build(t4, e3, n3, r3) {
              const o3 = e3.accounts.find((t5) => t5.isMut), i3 = !!e3.returns;
              if (!o3 && i3)
                return async (...o4) => {
                  var i4, s3;
                  let a3 = await n3(...o4);
                  const c3 = `Program return: ${t4} `;
                  let u4 = a3.raw.find((t5) => t5.startsWith(c3));
                  if (!u4)
                    throw new Error("View expected return log");
                  let d4 = E(u4.slice(c3.length)), l4 = e3.returns;
                  if (!l4)
                    throw new Error("View expected return type");
                  return Lt.fieldLayout({ type: l4 }, Array.from([...null !== (i4 = r3.accounts) && void 0 !== i4 ? i4 : [], ...null !== (s3 = r3.types) && void 0 !== s3 ? s3 : []])).decode(d4);
                };
            }
          }.build(n2, p3, g2, t3), v2 = Nn.build(r2, n2, p3, f2, m, y2, g2, w2, l3), b2 = (0, import_camelcase.default)(p3.name);
          i2[b2] = f2, s2[b2] = m, o2[b2] = y2, a2[b2] = g2, c2[b2] = v2, w2 && (u3[b2] = w2);
        }), [o2, i2, s2, l3, a2, c2, p2, u3];
      }
    }.build(t2, this._coder, e, n);
    this.rpc = o, this.instruction = i, this.transaction = s, this.account = a, this.simulate = c, this.methods = u2, this.state = d2, this.views = l2;
  }
  get programId() {
    return this._programId;
  }
  get idl() {
    return this._idl;
  }
  get coder() {
    return this._coder;
  }
  get provider() {
    return this._provider;
  }
  static async at(t2, e) {
    const n = L(t2), r = await Vn.fetchIdl(n, e);
    if (!r)
      throw new Error(`IDL not found for program: ${t2.toString()}`);
    return new Vn(r, n, e);
  }
  static async fetchIdl(t2, n) {
    n = null != n ? n : lt();
    const r = L(t2), o = await async function(t3) {
      const n2 = (await PublicKey.findProgramAddress([], t3))[0];
      return await PublicKey.createWithSeed(n2, "anchor:idl", t3);
    }(r), i = await n.connection.getAccountInfo(o);
    if (!i)
      return null;
    let s = (a = i.data.slice(8), gn.decode(a));
    var a;
    const c = inflate_1(s.data);
    return JSON.parse(v(c));
  }
  addEventListener(t2, e) {
    return this._events.addEventListener(t2, e);
  }
  async removeEventListener(t2) {
    return await this._events.removeEventListener(t2);
  }
};
var Un = class {
  constructor(t2) {
  }
  encode(t2, e) {
    if ("create" === (0, import_camelcase.default)(t2))
      return Buffer.alloc(0);
    throw new Error(`Invalid instruction: ${t2}`);
  }
  encodeState(t2, e) {
    throw new Error("SPL associated token does not have state");
  }
};
var jn = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("SPL associated token does not have state");
  }
  decode(t2) {
    throw new Error("SPL associated token does not have state");
  }
};
var $n = class {
  constructor(t2) {
    this.idl = t2;
  }
  async encode(t2, e) {
    throw new Error(`Invalid account name: ${t2}`);
  }
  decode(t2, e) {
    return this.decodeUnchecked(t2, e);
  }
  decodeUnchecked(t2, e) {
    throw new Error(`Invalid account name: ${t2}`);
  }
  memcmp(t2, e) {
    throw new Error(`Invalid account name: ${t2}`);
  }
  size(t2) {
    var e;
    return null !== (e = Bt(this.idl, t2)) && void 0 !== e ? e : 0;
  }
};
var Kn = class {
  constructor(t2) {
  }
  decode(t2) {
    throw new Error("SPL associated token program does not have events");
  }
};
var qn = class {
  constructor(t2) {
  }
  encode(t2, e) {
    throw new Error("SPL associated token does not have user-defined types");
  }
  decode(t2, e) {
    throw new Error("SPL associated token does not have user-defined types");
  }
};
var Fn = class {
  constructor(t2) {
    this.instruction = new Un(t2), this.accounts = new $n(t2), this.events = new Kn(t2), this.state = new jn(t2), this.types = new qn(t2);
  }
};
var Wn = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
function Gn(t2) {
  return new Vn(Hn, Wn, t2, new Fn(Hn));
}
var Hn = { version: "0.1.0", name: "spl_associated_token", instructions: [{ name: "create", accounts: [{ name: "authority", isMut: true, isSigner: true }, { name: "associatedAccount", isMut: true, isSigner: false }, { name: "owner", isMut: false, isSigner: false }, { name: "mint", isMut: false, isSigner: false }, { name: "systemProgram", isMut: false, isSigner: false }, { name: "tokenProgram", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [] }] };
var Jn = class {
  static token(t2) {
    return function(t3) {
      return new Vn(Bn, Cn, t3, zn());
    }(t2);
  }
  static associatedToken(t2) {
    return Gn(t2);
  }
};
var Zn = new PublicKey("11111111111111111111111111111111");
function Xn(t2) {
  return new Vn(Qn, Zn, t2, new Qe(Qn));
}
var Qn = { version: "0.1.0", name: "system_program", instructions: [{ name: "createAccount", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: true }], args: [{ name: "lamports", type: "u64" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "assign", accounts: [{ name: "pubkey", isMut: true, isSigner: true }], args: [{ name: "owner", type: "publicKey" }] }, { name: "transfer", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: false }], args: [{ name: "lamports", type: "u64" }] }, { name: "createAccountWithSeed", accounts: [{ name: "from", isMut: true, isSigner: true }, { name: "to", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "lamports", type: "u64" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "advanceNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "withdrawNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "to", isMut: true, isSigner: false }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "lamports", type: "u64" }] }, { name: "initializeNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: true }, { name: "recentBlockhashes", isMut: false, isSigner: false }, { name: "rent", isMut: false, isSigner: false }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "authorizeNonceAccount", accounts: [{ name: "nonce", isMut: true, isSigner: false }, { name: "authorized", isMut: false, isSigner: true }], args: [{ name: "authorized", type: "publicKey" }] }, { name: "allocate", accounts: [{ name: "pubkey", isMut: true, isSigner: true }], args: [{ name: "space", type: "u64" }] }, { name: "allocateWithSeed", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "space", type: "u64" }, { name: "owner", type: "publicKey" }] }, { name: "assignWithSeed", accounts: [{ name: "account", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }], args: [{ name: "base", type: "publicKey" }, { name: "seed", type: "string" }, { name: "owner", type: "publicKey" }] }, { name: "transferWithSeed", accounts: [{ name: "from", isMut: true, isSigner: false }, { name: "base", isMut: false, isSigner: true }, { name: "to", isMut: true, isSigner: false }], args: [{ name: "lamports", type: "u64" }, { name: "seed", type: "string" }, { name: "owner", type: "publicKey" }] }], accounts: [{ name: "nonce", type: { kind: "struct", fields: [{ name: "version", type: "u32" }, { name: "state", type: "u32" }, { name: "authorizedPubkey", type: "publicKey" }, { name: "nonce", type: "publicKey" }, { name: "feeCalculator", type: { defined: "FeeCalculator" } }] } }], types: [{ name: "FeeCalculator", type: { kind: "struct", fields: [{ name: "lamportsPerSignature", type: "u64" }] } }] };
var Yn = class {
  static system(t2) {
    return Xn(t2);
  }
};
var export_BN = import_bn2.default;
export {
  Dt as ACCOUNT_DISCRIMINATOR_SIZE,
  En as AccountClient,
  vt as AnchorError,
  st as AnchorProvider,
  export_BN as BN,
  Nt as BorshAccountsCoder,
  Kt as BorshCoder,
  Rt as BorshEventCoder,
  Tt as BorshInstructionCoder,
  Ut as BorshStateCoder,
  xn as EventManager,
  Pn as EventParser,
  gt as IdlError,
  _t as LangErrorCode,
  St as LangErrorMessage,
  Nn as MethodsBuilderFactory,
  Yn as Native,
  Vn as Program,
  bt as ProgramError,
  wt as ProgramErrorStack,
  Jn as Spl,
  Ne as SplTokenCoder,
  _n as StateClient,
  Qe as SystemCoder,
  Vt as eventDiscriminator,
  lt as getProvider,
  M as parseIdlErrors,
  dt as setProvider,
  wn as splitArgsAndCtx,
  jt as stateDiscriminator,
  x as toInstruction,
  L as translateAddress,
  At as translateError,
  yn as utils,
  P as validateAccounts,
  index_browser_esm_exports as web3
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
/**
 * Support for translating between Buffer instances and JavaScript
 * native types.
 *
 * {@link module:Layout~Layout|Layout} is the basis of a class
 * hierarchy that associates property names with sequences of encoded
 * bytes.
 *
 * Layouts are supported for these scalar (numeric) types:
 * * {@link module:Layout~UInt|Unsigned integers in little-endian
 *   format} with {@link module:Layout.u8|8-bit}, {@link
 *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
 *   {@link module:Layout.u32|32-bit}, {@link
 *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
 *   format} with {@link module:Layout.u16be|16-bit}, {@link
 *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
 *   {@link module:Layout.u40be|40-bit}, and {@link
 *   module:Layout.u48be|48-bit} representation ranges;
 * * {@link module:Layout~Int|Signed integers in little-endian
 *   format} with {@link module:Layout.s8|8-bit}, {@link
 *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
 *   {@link module:Layout.s32|32-bit}, {@link
 *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
 *   representation ranges;
 * * {@link module:Layout~IntBE|Signed integers in big-endian format}
 *   with {@link module:Layout.s16be|16-bit}, {@link
 *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
 *   {@link module:Layout.s40be|40-bit}, and {@link
 *   module:Layout.s48be|48-bit} representation ranges;
 * * 64-bit integral values that decode to an exact (if magnitude is
 *   less than 2^53) or nearby integral Number in {@link
 *   module:Layout.nu64|unsigned little-endian}, {@link
 *   module:Layout.nu64be|unsigned big-endian}, {@link
 *   module:Layout.ns64|signed little-endian}, and {@link
 *   module:Layout.ns64be|unsigned big-endian} encodings;
 * * 32-bit floating point values with {@link
 *   module:Layout.f32|little-endian} and {@link
 *   module:Layout.f32be|big-endian} representations;
 * * 64-bit floating point values with {@link
 *   module:Layout.f64|little-endian} and {@link
 *   module:Layout.f64be|big-endian} representations;
 * * {@link module:Layout.const|Constants} that take no space in the
 *   encoded expression.
 *
 * and for these aggregate types:
 * * {@link module:Layout.seq|Sequence}s of instances of a {@link
 *   module:Layout~Layout|Layout}, with JavaScript representation as
 *   an Array and constant or data-dependent {@link
 *   module:Layout~Sequence#count|length};
 * * {@link module:Layout.struct|Structure}s that aggregate a
 *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
 *   instances, with JavaScript representation as an Object;
 * * {@link module:Layout.union|Union}s that support multiple {@link
 *   module:Layout~VariantLayout|variant layouts} over a fixed
 *   (padded) or variable (not padded) span of bytes, using an
 *   unsigned integer at the start of the data or a separate {@link
 *   module:Layout.unionLayoutDiscriminator|layout element} to
 *   determine which layout to use when interpreting the buffer
 *   contents;
 * * {@link module:Layout.bits|BitStructure}s that contain a sequence
 *   of individual {@link
 *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
 *   16, 24, or 32-bit unsigned integer starting at the least- or
 *   most-significant bit;
 * * {@link module:Layout.cstr|C strings} of varying length;
 * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
 *   module:Layout~Blob#length|length} raw data.
 *
 * All {@link module:Layout~Layout|Layout} instances are immutable
 * after construction, to prevent internal state from becoming
 * inconsistent.
 *
 * @local Layout
 * @local ExternalLayout
 * @local GreedyCount
 * @local OffsetLayout
 * @local UInt
 * @local UIntBE
 * @local Int
 * @local IntBE
 * @local NearUInt64
 * @local NearUInt64BE
 * @local NearInt64
 * @local NearInt64BE
 * @local Float
 * @local FloatBE
 * @local Double
 * @local DoubleBE
 * @local Sequence
 * @local Structure
 * @local UnionDiscriminator
 * @local UnionLayoutDiscriminator
 * @local Union
 * @local VariantLayout
 * @local BitStructure
 * @local BitField
 * @local Boolean
 * @local Blob
 * @local CString
 * @local Constant
 * @local bindConstructorLayout
 * @module Layout
 * @license MIT
 * @author Peter A. Bigot
 * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
 */
/**
 * [js-sha256]{@link https://github.com/emn178/js-sha256}
 *
 * @version 0.9.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2014-2017
 * @license MIT
 */
//# sourceMappingURL=@project-serum_anchor.js.map
